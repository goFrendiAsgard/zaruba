
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>booleanutil: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/state-alchemists/zaruba/booleanutil/boolean.go (100.0%)</option>
				
				<option value="file1">github.com/state-alchemists/zaruba/dsl/configRef.go (0.0%)</option>
				
				<option value="file2">github.com/state-alchemists/zaruba/dsl/dslUtil.go (100.0%)</option>
				
				<option value="file3">github.com/state-alchemists/zaruba/dsl/envRef.go (0.0%)</option>
				
				<option value="file4">github.com/state-alchemists/zaruba/dsl/keyvalidator.go (100.0%)</option>
				
				<option value="file5">github.com/state-alchemists/zaruba/dsl/project.go (79.7%)</option>
				
				<option value="file6">github.com/state-alchemists/zaruba/dsl/projectUtil.go (3.6%)</option>
				
				<option value="file7">github.com/state-alchemists/zaruba/dsl/setDefaultEnv.go (66.7%)</option>
				
				<option value="file8">github.com/state-alchemists/zaruba/dsl/task.go (68.1%)</option>
				
				<option value="file9">github.com/state-alchemists/zaruba/dsl/taskConfigUtil.go (1.5%)</option>
				
				<option value="file10">github.com/state-alchemists/zaruba/dsl/taskEnvUtil.go (0.7%)</option>
				
				<option value="file11">github.com/state-alchemists/zaruba/dsl/taskUtil.go (5.4%)</option>
				
				<option value="file12">github.com/state-alchemists/zaruba/dsl/tpl.go (55.3%)</option>
				
				<option value="file13">github.com/state-alchemists/zaruba/dsl/variable.go (100.0%)</option>
				
				<option value="file14">github.com/state-alchemists/zaruba/runner/runner.go (88.3%)</option>
				
				<option value="file15">github.com/state-alchemists/zaruba/runner/taskstatus.go (100.0%)</option>
				
				<option value="file16">github.com/state-alchemists/zaruba/strutil/namegenerator.go (20.0%)</option>
				
				<option value="file17">github.com/state-alchemists/zaruba/strutil/replacementMapKey.go (100.0%)</option>
				
				<option value="file18">github.com/state-alchemists/zaruba/strutil/strHelper.go (74.8%)</option>
				
				<option value="file19">github.com/state-alchemists/zaruba/strutil/strUtil.go (50.8%)</option>
				
				<option value="file20">github.com/state-alchemists/zaruba/toc/helper.go (90.0%)</option>
				
				<option value="file21">github.com/state-alchemists/zaruba/toc/toc.go (78.6%)</option>
				
				<option value="file22">github.com/state-alchemists/zaruba/toc/tocitem.go (85.7%)</option>
				
				<option value="file23">github.com/state-alchemists/zaruba/toc/tocitems.go (92.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package booleanutil

import "strings"

type BooleanUtil struct{}

func NewBooleanUtil() *BooleanUtil <span class="cov10" title="46">{
        return &amp;BooleanUtil{}
}</span>

// IsTrue check whether str is semantically equal to "true"
func (booleanUtil *BooleanUtil) IsTrue(str string) bool <span class="cov8" title="23">{
        lowerStr := strings.ToLower(str)
        return lowerStr == "yes" || lowerStr == "y" || lowerStr == "true" || lowerStr == "on" || lowerStr == "1"
}</span>

// IsFalse check whether str is semantically equal to "true"
func (booleanUtil *BooleanUtil) IsFalse(str string) bool <span class="cov8" title="23">{
        lowerStr := strings.ToLower(str)
        return lowerStr == "no" || lowerStr == "n" || lowerStr == "false" || lowerStr == "off" || lowerStr == "0"
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package dsl

type ConfigRef struct {
        Map          map[string]string
        fileLocation string
        name         string
}

func (c *ConfigRef) GetFileLocation() string <span class="cov0" title="0">{
        return c.fileLocation
}</span>

func (c *ConfigRef) GetName() string <span class="cov0" title="0">{
        return c.name
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package dsl

import (
        "github.com/state-alchemists/zaruba/booleanutil"
        "github.com/state-alchemists/zaruba/dictutil"
        "github.com/state-alchemists/zaruba/fileutil"
        "github.com/state-alchemists/zaruba/jsonutil"
        "github.com/state-alchemists/zaruba/listutil"
        "github.com/state-alchemists/zaruba/pathutil"
        "github.com/state-alchemists/zaruba/strutil"
)

type DSLUtil struct {
        Str     *strutil.StrUtil
        List    *listutil.ListUtil
        Dict    *dictutil.DictUtil
        File    *fileutil.FileUtil
        Bool    *booleanutil.BooleanUtil
        Path    *pathutil.PathUtil
        Json    *jsonutil.JsonUtil
        Project *ProjectUtil
}

func NewDSLUtil() *DSLUtil <span class="cov10" title="121">{
        strUtil := strutil.NewStrUtil()
        listUtil := listutil.NewListUtil()
        dictUtil := dictutil.NewDictUtil()
        jsonUtil := jsonutil.NewJsonUtil(strUtil)
        fileUtil := fileutil.NewFileUtil(jsonUtil)
        projectUtil := NewProjectUtil(fileUtil, jsonUtil)
        pathUtil := pathutil.NewPathUtil(jsonUtil)
        booleanUtil := booleanutil.NewBooleanUtil()
        coreUtil := &amp;DSLUtil{
                Str:     strUtil,
                List:    listUtil,
                Dict:    dictUtil,
                File:    fileUtil,
                Bool:    booleanUtil,
                Path:    pathUtil,
                Json:    jsonUtil,
                Project: projectUtil,
        }
        return coreUtil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package dsl

type EnvRef struct {
        Map          map[string]*Env
        Project      *Project
        fileLocation string
        name         string
}

func (e *EnvRef) GetFileLocation() string <span class="cov0" title="0">{
        return e.fileLocation
}</span>

func (e *EnvRef) GetName() string <span class="cov0" title="0">{
        return e.name
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package dsl

import (
        "fmt"
        "io/ioutil"

        yaml "gopkg.in/yaml.v3"
)

type TaskEnvKeyCheckData struct {
        Envs map[string]map[string]interface{} `yaml:"envs,omitempty"`
}

type TaskWithEnvKeyCheckData struct {
        Tasks map[string]TaskEnvKeyCheckData `yaml:"tasks,omitempty"`
}

type TaskKeyCheckData struct {
        Tasks map[string]map[string]interface{} `yaml:"tasks,omitempty"`
}

type EnvKeyCheckData struct {
        Envs map[string]map[string]map[string]interface{} `yaml:"envs,omitempty"`
}

type InputKeyCheckData struct {
        Variables map[string]map[string]interface{} `yaml:"inputs,omitempty"`
}

// KeyValidator structure validator
type KeyValidator struct {
        fileName                string
        rawData                 map[string]interface{}
        envKeyCheckData         EnvKeyCheckData
        taskKeyCheckData        TaskKeyCheckData
        taskWithEnvKeyCheckData TaskWithEnvKeyCheckData
        inputKeyCheckData       InputKeyCheckData
}

func NewKeyValidator(fileName string) (sv *KeyValidator) <span class="cov6" title="121">{
        return &amp;KeyValidator{
                fileName: fileName,
                rawData:  map[string]interface{}{},
                envKeyCheckData: EnvKeyCheckData{
                        Envs: map[string]map[string]map[string]interface{}{},
                },
                inputKeyCheckData: InputKeyCheckData{
                        Variables: map[string]map[string]interface{}{},
                },
                taskKeyCheckData: TaskKeyCheckData{
                        Tasks: map[string]map[string]interface{}{},
                },
                taskWithEnvKeyCheckData: TaskWithEnvKeyCheckData{
                        Tasks: map[string]TaskEnvKeyCheckData{},
                },
        }
}</span>

func (kv *KeyValidator) Validate() (b []byte, err error) <span class="cov6" title="121">{
        b, err = ioutil.ReadFile(kv.fileName)
        if err != nil </span><span class="cov1" title="2">{
                return b, fmt.Errorf("error reading file '%s': %s", kv.fileName, err)
        }</span>
        <span class="cov6" title="119">if err = yaml.Unmarshal(b, &amp;kv.rawData); err != nil </span><span class="cov1" title="1">{
                return b, fmt.Errorf("error parsing YAML '%s': %s", kv.fileName, err)
        }</span>
        <span class="cov6" title="118">if err = yaml.Unmarshal(b, &amp;kv.envKeyCheckData); err != nil </span><span class="cov1" title="1">{
                return b, fmt.Errorf("error parsing YAML '%s': %s", kv.fileName, err)
        }</span>
        <span class="cov6" title="117">if err = yaml.Unmarshal(b, &amp;kv.inputKeyCheckData); err != nil </span><span class="cov1" title="1">{
                return b, fmt.Errorf("error parsing YAML '%s': %s", kv.fileName, err)
        }</span>
        <span class="cov6" title="116">if err = yaml.Unmarshal(b, &amp;kv.taskKeyCheckData); err != nil </span><span class="cov1" title="1">{
                return b, fmt.Errorf("error parsing YAML '%s': %s", kv.fileName, err)
        }</span>
        <span class="cov6" title="115">if err = yaml.Unmarshal(b, &amp;kv.taskWithEnvKeyCheckData); err != nil </span><span class="cov1" title="1">{
                return b, fmt.Errorf("error parsing YAML '%s': %s", kv.fileName, err)
        }</span>
        <span class="cov6" title="114">if err = kv.checkProjectValidKeys(); err != nil </span><span class="cov1" title="1">{
                return b, err
        }</span>
        <span class="cov6" title="113">if err = kv.checkEnvValidKeys(); err != nil </span><span class="cov1" title="1">{
                return b, err
        }</span>
        <span class="cov6" title="112">if err = kv.checkInputValidKeys(); err != nil </span><span class="cov1" title="1">{
                return b, err
        }</span>
        <span class="cov6" title="111">if err = kv.checkTaskValidKeys(); err != nil </span><span class="cov1" title="1">{
                return b, err
        }</span>
        <span class="cov6" title="110">if err = kv.checkTaskEnvValidKeys(); err != nil </span><span class="cov1" title="1">{
                return b, err
        }</span>
        <span class="cov6" title="109">return b, nil</span>
}

func (kv *KeyValidator) checkProjectValidKeys() (err error) <span class="cov6" title="114">{
        validKeys := []string{"includes", "tasks", "name", "inputs", "envs", "configs"}
        for key := range kv.rawData </span><span class="cov6" title="149">{
                isValid := false
                for _, validKey := range validKeys </span><span class="cov8" title="427">{
                        if validKey == key </span><span class="cov6" title="148">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov6" title="149">if !isValid </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid key on '%s': %s", kv.fileName, key)
                }</span>
        }
        <span class="cov6" title="113">return nil</span>
}

func (kv *KeyValidator) checkTaskValidKeys() (err error) <span class="cov6" title="111">{
        validKeys := []string{"start", "maxStartRetry", "startRetryDelay", "check", "maxCheckRetry", "checkRetryDelay", "timeout", "private", "autoTerminate", "extend", "extends", "location", "configRef", "configRefs", "configs", "envRef", "envRefs", "envs", "dependencies", "inputs", "description", "icon", "saveLog", "syncEnv", "syncEnvLocation"}
        for taskName, task := range kv.taskKeyCheckData.Tasks </span><span class="cov7" title="161">{
                for key := range task </span><span class="cov7" title="178">{
                        valid := false
                        for _, validKey := range validKeys </span><span class="cov10" title="1986">{
                                if key == validKey </span><span class="cov7" title="177">{
                                        valid = true
                                        break</span>
                                }
                        }
                        <span class="cov7" title="178">if !valid </span><span class="cov1" title="1">{
                                return fmt.Errorf("invalid key on '%s': tasks[%s][%s]", kv.fileName, taskName, key)
                        }</span>
                }
        }
        <span class="cov6" title="110">return nil</span>
}

func (kv *KeyValidator) checkEnvValidKeys() (err error) <span class="cov6" title="113">{
        for envRefName, env := range kv.envKeyCheckData.Envs </span><span class="cov4" title="14">{
                if err = kv.checkEnvMapValidKeys(env, fmt.Sprintf("envs[%s]", envRefName)); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov6" title="112">return nil</span>
}

func (kv *KeyValidator) checkInputValidKeys() (err error) <span class="cov6" title="112">{
        validKeys := []string{"default", "description", "secret", "validation", "options", "prompt", "allowCustom"}
        for inputName, input := range kv.inputKeyCheckData.Variables </span><span class="cov5" title="44">{
                for key := range input </span><span class="cov4" title="17">{
                        valid := false
                        for _, validKey := range validKeys </span><span class="cov5" title="61">{
                                if key == validKey </span><span class="cov4" title="16">{
                                        valid = true
                                        break</span>
                                }
                        }
                        <span class="cov4" title="17">if !valid </span><span class="cov1" title="1">{
                                return fmt.Errorf("invalid key on '%s': inputs[%s][%s]", kv.fileName, inputName, key)
                        }</span>
                }
        }
        <span class="cov6" title="111">return nil</span>
}

func (kv *KeyValidator) checkTaskEnvValidKeys() (err error) <span class="cov6" title="110">{
        for taskName, task := range kv.taskWithEnvKeyCheckData.Tasks </span><span class="cov7" title="160">{
                if err = kv.checkEnvMapValidKeys(task.Envs, fmt.Sprintf("tasks[%s][envs]", taskName)); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov6" title="109">return nil</span>
}

func (kv *KeyValidator) checkEnvMapValidKeys(envMap map[string]map[string]interface{}, errorKeyPrefix string) (err error) <span class="cov7" title="174">{
        validKeys := []string{"from", "default"}
        for envName := range envMap </span><span class="cov4" title="28">{
                for key := range envMap[envName] </span><span class="cov5" title="41">{
                        valid := false
                        for _, validKey := range validKeys </span><span class="cov6" title="69">{
                                if key == validKey </span><span class="cov5" title="39">{
                                        valid = true
                                        break</span>
                                }
                        }
                        <span class="cov5" title="41">if !valid </span><span class="cov1" title="2">{
                                return fmt.Errorf("invalid key on '%s': %s[%s][%s]", kv.fileName, errorKeyPrefix, envName, key)
                        }</span>
                }
        }
        <span class="cov7" title="172">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dsl

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"

        "github.com/joho/godotenv"
        "github.com/state-alchemists/zaruba/output"
        yaml "gopkg.in/yaml.v3"
)

// Project is zaruba configuration
type Project struct {
        Name                       string                       `yaml:"name,omitempty"`
        Includes                   []string                     `yaml:"includes,omitempty"`
        Inputs                     map[string]*Variable         `yaml:"inputs,omitempty"`
        Tasks                      map[string]*Task             `yaml:"tasks,omitempty"`
        RawEnvRefMap               map[string]map[string]*Env   `yaml:"envs,omitempty"`
        RawConfigRefMap            map[string]map[string]string `yaml:"configs,omitempty"`
        EnvRefMap                  map[string]*EnvRef           `yaml:"_envrefmap,omitempty"`
        ConfigRefMap               map[string]*ConfigRef        `yaml:"_configrefmap,omitempty"`
        IsInitialized              bool                         `yaml:"_isInitialized,omitempty"`
        StdoutChan                 chan string
        StdoutRecordChan           chan []string
        StderrChan                 chan string
        StderrRecordChan           chan []string
        OutputWg                   *sync.WaitGroup
        OutputWgMutex              *sync.Mutex
        fileLocation               string
        values                     map[string]string
        sortedTaskNames            []string
        sortedInputNames           []string
        maxPublishedTaskNameLength int
        Decoration                 *output.Decoration
        Util                       *DSLUtil
        additionalEnvNames         []string
        additionalValueNames       []string
        showLogTime                bool
        sessionId                  string
}

func NewDefaultProject(projectFile string) (p *Project, err error) <span class="cov0" title="0">{
        return NewProject(projectFile, output.NewDefaultDecoration(), true)
}</span>

func NewProject(projectFile string, decoration *output.Decoration, showLogTime bool) (p *Project, err error) <span class="cov0" title="0">{
        defaultIncludes := []string{"${ZARUBA_HOME}/core.zaruba.yaml"}
        for _, script := range strings.Split(os.Getenv("ZARUBA_SCRIPTS"), ":") </span><span class="cov0" title="0">{
                if script == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">defaultIncludes = append(defaultIncludes, script)</span>
        }
        <span class="cov0" title="0">return NewCustomProject(projectFile, decoration, showLogTime, defaultIncludes)</span>
}

// NewCustomProject create new Config from Yaml File
func NewCustomProject(projectFile string, decoration *output.Decoration, showLogTime bool, defaultIncludes []string) (p *Project, err error) <span class="cov7" title="107">{
        p, err = loadProject(decoration, projectFile, defaultIncludes)
        if err != nil </span><span class="cov5" title="17">{
                return p, err
        }</span>
        <span class="cov7" title="90">p.StdoutChan = make(chan string)
        p.StdoutRecordChan = make(chan []string)
        p.StderrChan = make(chan string)
        p.StderrRecordChan = make(chan []string)
        p.OutputWg = new(sync.WaitGroup)
        p.OutputWgMutex = new(sync.Mutex)
        p.Decoration = decoration
        p.showLogTime = showLogTime
        p.setSortedTaskNames()
        p.setSortedInputNames()
        p.linkToTasks()
        p.linkToInputs()
        p.setDefaultValues()
        p.generateSessionId()
        if err = p.validateTask(); err != nil </span><span class="cov4" title="13">{
                return p, err
        }</span>
        <span class="cov7" title="77">for _, taskName := range p.sortedTaskNames </span><span class="cov8" title="134">{
                task := p.Tasks[taskName]
                task.init()
        }</span>
        <span class="cov7" title="77">return p, err</span>
}

func loadProject(d *output.Decoration, projectFile string, defaultIncludes []string) (p *Project, err error) <span class="cov8" title="121">{
        parsedProjectFile, err := parseProjectFile(projectFile)
        if err != nil </span><span class="cov0" title="0">{
                return p, err
        }</span>
        <span class="cov8" title="121">p, err = newRawProject(parsedProjectFile)
        if err != nil </span><span class="cov4" title="13">{
                return p, err
        }</span>
        <span class="cov7" title="108">p.include(parsedProjectFile, defaultIncludes)
        p.fileLocation = parsedProjectFile
        p.setTaskFileLocation()
        p.setInputFileLocation()
        p.setProjectEnvRefMap()
        p.setProjectConfigRefMap()
        // cascade project, add inclusion's property to this project
        if err = p.cascadeIncludes(d); err != nil </span><span class="cov3" title="5">{
                return p, err
        }</span>
        <span class="cov7" title="103">return p, err</span>
}

func parseProjectFile(projectFile string) (parsedProjectFile string, err error) <span class="cov8" title="121">{
        if projectFile == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="121">return filepath.Abs(os.ExpandEnv(projectFile))</span>
}

func newRawProject(parsedProjectFile string) (p *Project, err error) <span class="cov8" title="121">{
        p = &amp;Project{
                Includes:                   []string{},
                RawEnvRefMap:               map[string]map[string]*Env{},
                RawConfigRefMap:            map[string]map[string]string{},
                Tasks:                      map[string]*Task{},
                Inputs:                     map[string]*Variable{},
                values:                     map[string]string{},
                EnvRefMap:                  map[string]*EnvRef{},
                ConfigRefMap:               map[string]*ConfigRef{},
                IsInitialized:              false,
                maxPublishedTaskNameLength: 20,
                Util:                       NewDSLUtil(),
        }
        if parsedProjectFile == "" </span><span class="cov0" title="0">{
                return p, nil
        }</span>
        <span class="cov8" title="121">keyValidator := NewKeyValidator(parsedProjectFile)
        b, err := keyValidator.Validate()
        if err != nil </span><span class="cov4" title="12">{
                return p, err
        }</span>
        <span class="cov7" title="109">if err = yaml.Unmarshal(b, p); err != nil </span><span class="cov1" title="1">{
                return p, fmt.Errorf("error parsing YAML '%s': %s", parsedProjectFile, err)
        }</span>
        <span class="cov7" title="108">return p, nil</span>
}

func (p *Project) include(parsedProjectFile string, defaultIncludes []string) <span class="cov7" title="108">{
        for _, script := range defaultIncludes </span><span class="cov0" title="0">{
                if strings.Trim(script, " ") == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">parsedScript, _ := filepath.Abs(os.ExpandEnv(script))
                if parsedScript == parsedProjectFile </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">shouldIncludeParsedScript := true
                for _, currentInclude := range p.Includes </span><span class="cov0" title="0">{
                        parsedCurrentInclude, _ := filepath.Abs(os.ExpandEnv(currentInclude))
                        if parsedScript == parsedCurrentInclude </span><span class="cov0" title="0">{
                                shouldIncludeParsedScript = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if shouldIncludeParsedScript </span><span class="cov0" title="0">{
                        p.Includes = append(p.Includes, parsedScript)
                }</span>
        }
}

func (p *Project) GetSessionId() (sessionId string) <span class="cov3" title="7">{
        return p.sessionId
}</span>

// GetName get projectName
func (p *Project) GetName() (name string) <span class="cov8" title="135">{
        if p.Name != "" </span><span class="cov1" title="1">{
                return p.Name
        }</span>
        <span class="cov8" title="134">return filepath.Base(p.GetDirPath())</span>
}

// GetFileLocation
func (p *Project) GetFileLocation() (fileLocation string) <span class="cov0" title="0">{
        return p.fileLocation
}</span>

func (p *Project) GetDirPath() (dirPath string) <span class="cov10" title="418">{
        if p.fileLocation == "" </span><span class="cov0" title="0">{
                dirPath, _ = os.Getwd()
                return dirPath
        }</span>
        <span class="cov10" title="418">return filepath.Dir(p.fileLocation)</span>
}

// GetSortedInputNames get sorted input names
func (p *Project) GetSortedInputNames() (sortedInputNames []string) <span class="cov1" title="1">{
        return p.sortedInputNames
}</span>

// GetSortedTaskNames get sorted task names
func (p *Project) GetSortedTaskNames() (sortedTaskNames []string) <span class="cov1" title="1">{
        return p.sortedTaskNames
}</span>

// GetValues get value
func (p *Project) GetValues() (values map[string]string) <span class="cov1" title="1">{
        return p.values
}</span>

// GetValue get value
func (p *Project) GetValue(key string) (value string) <span class="cov4" title="9">{
        return p.values[key]
}</span>

// IsValueExist is value exist
func (p *Project) IsValueExist(key string) (exist bool) <span class="cov4" title="9">{
        _, exist = p.values[key]
        return exist
}</span>

// AddEnv add global environment for a projectConfig
func (p *Project) AddEnv(newEnv string) (err error) <span class="cov3" title="5">{
        if p.IsInitialized </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot AddEnv, project has been initialized")
        }</span>
        <span class="cov3" title="4">p.additionalEnvNames = append(p.additionalEnvNames, newEnv)
        // load env from json string
        envMap := map[string]string{}
        if err := json.Unmarshal([]byte(newEnv), &amp;envMap); err == nil </span><span class="cov0" title="0">{
                for key := range envMap </span><span class="cov0" title="0">{
                        val := envMap[key]
                        os.Setenv(key, val)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        // load env from file
        <span class="cov3" title="4">if _, err := os.Stat(newEnv); !os.IsNotExist(err) </span><span class="cov1" title="1">{
                return godotenv.Load(newEnv)
        }</span>
        // load env from string
        <span class="cov2" title="3">pairParts := strings.SplitN(newEnv, "=", 2)
        if len(pairParts) == 2 </span><span class="cov2" title="3">{
                key := pairParts[0]
                val := pairParts[1]
                os.Setenv(key, val)
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("invalid env: %s", newEnv)</span>
}

func (p *Project) GetAdditionalEnvNames() []string <span class="cov0" title="0">{
        return p.additionalEnvNames
}</span>

// AddValue add value for a project
func (p *Project) AddValue(newValue string) (err error) <span class="cov4" title="14">{
        if p.IsInitialized </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot AddValue, project has been initialized")
        }</span>
        <span class="cov4" title="13">p.additionalValueNames = append(p.additionalValueNames, newValue)
        // load values from json string
        valueMap := map[string]string{}
        if err := json.Unmarshal([]byte(newValue), &amp;valueMap); err == nil </span><span class="cov0" title="0">{
                for key := range valueMap </span><span class="cov0" title="0">{
                        val := valueMap[key]
                        p.values[key] = val
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        // load values from file
        <span class="cov4" title="13">if _, err := os.Stat(newValue); !os.IsNotExist(err) </span><span class="cov3" title="7">{
                b, err := ioutil.ReadFile(newValue)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="7">keyValues := map[string]string{}
                if err = yaml.Unmarshal(b, keyValues); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov3" title="6">for key, val := range keyValues </span><span class="cov4" title="9">{
                        p.values[key] = val
                }</span>
                <span class="cov3" title="6">return nil</span>
        }
        // load values from string
        <span class="cov3" title="6">pairParts := strings.SplitN(newValue, "=", 2)
        if len(pairParts) == 2 </span><span class="cov3" title="5">{
                key := pairParts[0]
                val := pairParts[1]
                p.values[key] = val
                return nil
        }</span>
        <span class="cov1" title="1">return fmt.Errorf("invalid value: %s", newValue)</span>
}

// SetValue set value for a project
func (p *Project) SetValue(key, value string) (err error) <span class="cov4" title="9">{
        if p.IsInitialized </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot SetValue, project has been initialized")
        }</span>
        <span class="cov4" title="8">p.additionalValueNames = append(p.additionalValueNames, fmt.Sprintf("%s=%s", key, value))
        p.setValue(key, value)
        return nil</span>
}

func (p *Project) GetAdditionalValueNames() []string <span class="cov0" title="0">{
        return p.additionalValueNames
}</span>

func (p *Project) setValue(key, value string) <span class="cov6" title="47">{
        p.values[key] = value
}</span>

// GetInputs given task names
func (p *Project) GetInputs(taskNames []string) (inputs map[string]*Variable, inputOrder []string, err error) <span class="cov9" title="306">{
        inputs = map[string]*Variable{}
        inputOrder = []string{}
        for _, taskName := range taskNames </span><span class="cov8" title="154">{
                task, taskExist := p.Tasks[taskName]
                if !taskExist </span><span class="cov1" title="1">{
                        return inputs, inputOrder, fmt.Errorf("task '%s' does not exist", taskName)
                }</span>
                // include task's dependencies
                <span class="cov8" title="153">dependencyTaskNames := []string{}
                dependencyTaskNames = append(dependencyTaskNames, task.Dependencies...)
                dependencyInputs, dependencyInputOrder, _ := p.GetInputs(dependencyTaskNames)
                for _, inputName := range dependencyInputOrder </span><span class="cov2" title="2">{
                        subInput := dependencyInputs[inputName]
                        if _, inputRegistered := inputs[inputName]; !inputRegistered </span><span class="cov2" title="2">{
                                inputOrder = append(inputOrder, inputName)
                                inputs[inputName] = subInput
                        }</span>
                }
                // include task's inputs
                <span class="cov8" title="153">for _, inputName := range task.Inputs </span><span class="cov3" title="4">{
                        input := p.Inputs[inputName]
                        if _, inputRegistered := inputs[inputName]; !inputRegistered </span><span class="cov3" title="4">{
                                inputOrder = append(inputOrder, inputName)
                                inputs[inputName] = input
                        }</span>
                }
        }
        <span class="cov9" title="305">return inputs, inputOrder, err</span>
}

// Init all tasks
func (p *Project) Init() (err error) <span class="cov7" title="67">{
        for key, value := range p.values </span><span class="cov6" title="30">{
                parsedValue := os.ExpandEnv(value)
                // validate (allow empty value, but throw error if value is set and invalid)
                if parsedValue != "" </span><span class="cov5" title="20">{
                        if input, inputExist := p.Inputs[key]; inputExist </span><span class="cov4" title="12">{
                                if err = input.Validate(parsedValue); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>
                        }
                }
                // inject envvars (useful for secret inputs)
                <span class="cov6" title="29">p.values[key] = parsedValue
                inputEnvKey := "ZARUBA_INPUT_" + p.Util.Str.ToUpperSnake(key)
                os.Setenv(inputEnvKey, parsedValue)</span>
        }
        <span class="cov7" title="66">p.IsInitialized = true
        return err</span>
}

func (p *Project) GetAutoTerminate(taskNames []string) (autoTerminate bool) <span class="cov0" title="0">{
        for _, taskName := range taskNames </span><span class="cov0" title="0">{
                if !p.Tasks[taskName].GetAutoTerminate() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// ValidateByTaskNames validate by task names and throw error if invalid
func (p *Project) ValidateByTaskNames(taskNames []string) (err error) <span class="cov2" title="3">{
        for _, taskName := range taskNames </span><span class="cov2" title="3">{
                task, taskExist := p.Tasks[taskName]
                if !taskExist </span><span class="cov1" title="1">{
                        return fmt.Errorf("task '%s' does not exist", taskName)
                }</span>
                <span class="cov2" title="2">for _, inputName := range task.Inputs </span><span class="cov2" title="2">{
                        value := p.values[inputName]
                        if input, inputExist := p.Inputs[inputName]; inputExist </span><span class="cov2" title="2">{
                                if err = input.Validate(value); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return nil</span>
}

func (p *Project) GetValueFileNames() (valueFileNames []string, err error) <span class="cov0" title="0">{
        projectDir := filepath.Dir(p.GetFileLocation())
        files, err := ioutil.ReadDir(projectDir)
        if err != nil </span><span class="cov0" title="0">{
                return valueFileNames, err
        }</span>
        <span class="cov0" title="0">valueFileNames = []string{}
        for _, file := range files </span><span class="cov0" title="0">{
                isDir := file.IsDir()
                if isDir </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fileName := file.Name()
                if !strings.HasSuffix(fileName, ".values.yaml") || fileName == ".previous.values.yaml" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">valueFileNames = append(valueFileNames, filepath.Join(projectDir, fileName))</span>
        }
        <span class="cov0" title="0">return valueFileNames, nil</span>
}

func (p *Project) GetEnvFileNames() (envFileNames []string, err error) <span class="cov0" title="0">{
        projectDir := filepath.Dir(p.GetFileLocation())
        files, err := ioutil.ReadDir(projectDir)
        if err != nil </span><span class="cov0" title="0">{
                return envFileNames, err
        }</span>
        <span class="cov0" title="0">envFileNames = []string{}
        for _, file := range files </span><span class="cov0" title="0">{
                isDir := file.IsDir()
                if isDir </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fileName := file.Name()
                if !strings.HasSuffix(fileName, ".env") &amp;&amp; !strings.HasSuffix(fileName, ".env.template") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">envFileNames = append(envFileNames, filepath.Join(projectDir, fileName))</span>
        }
        <span class="cov0" title="0">return envFileNames, nil</span>
}

func (p *Project) setProjectEnvRefMap() <span class="cov7" title="108">{
        for envRefName, envRefMap := range p.RawEnvRefMap </span><span class="cov4" title="12">{
                p.EnvRefMap[envRefName] = &amp;EnvRef{
                        fileLocation: p.fileLocation,
                        name:         envRefName,
                        Map:          envRefMap,
                }
        }</span>
}

func (p *Project) setProjectConfigRefMap() <span class="cov7" title="108">{
        for configRefName, configRefMap := range p.RawConfigRefMap </span><span class="cov4" title="12">{
                p.ConfigRefMap[configRefName] = &amp;ConfigRef{
                        fileLocation: p.fileLocation,
                        name:         configRefName,
                        Map:          configRefMap,
                }
        }</span>
}

func (p *Project) setTaskFileLocation() <span class="cov7" title="108">{
        for _, task := range p.Tasks </span><span class="cov8" title="156">{
                task.fileLocation = p.fileLocation
        }</span>
}

func (p *Project) setInputFileLocation() <span class="cov7" title="108">{
        for _, input := range p.Inputs </span><span class="cov6" title="42">{
                input.fileLocation = p.fileLocation
        }</span>
}

func (p *Project) setDefaultValues() <span class="cov7" title="90">{
        for inputName, input := range p.Inputs </span><span class="cov6" title="39">{
                p.setValue(inputName, input.DefaultValue)
        }</span>
}

func (p *Project) validateTask() (err error) <span class="cov7" title="90">{
        if err = p.validateTaskExtend(); err != nil </span><span class="cov2" title="3">{
                return err
        }</span>
        <span class="cov7" title="87">if err = p.validateTaskDependencies(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov7" title="86">if err = p.validateTaskAcyclic(); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>
        <span class="cov7" title="84">if err = p.validateTaskInputs(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov7" title="83">if err = p.validateTaskEnvRef(); err != nil </span><span class="cov2" title="3">{
                return err
        }</span>
        <span class="cov7" title="80">if err = p.validateTaskConfigRef(); err != nil </span><span class="cov2" title="3">{
                return err
        }</span>
        <span class="cov7" title="77">if err = p.validateTaskAutoTerminte(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="77">return nil</span>
}

func (p *Project) validateTaskAutoTerminte() (err error) <span class="cov7" title="77">{
        for _, task := range p.Tasks </span><span class="cov8" title="134">{
                autoTerminate := task.GetAutoTerminate()
                haveCheckCmd := task.IsHavingCheckCmd()
                if haveCheckCmd &amp;&amp; autoTerminate </span><span class="cov0" title="0">{
                        return fmt.Errorf("restricted autoTerminate value on '%s': Task '%s' is autoTerminate, but tasks[%s][check] is not empty (also check task's parents)", task.GetFileLocation(), task.GetName(), task.GetName())
                }</span>
        }
        <span class="cov7" title="77">return nil</span>
}

func (p *Project) validateTaskAcyclic() (err error) <span class="cov7" title="86">{
        for _, task := range p.Tasks </span><span class="cov8" title="143">{
                isRecursive, recursiveTaskname := p.isTaskRecursive(task, []string{})
                if isRecursive </span><span class="cov2" title="2">{
                        recursiveTask := p.Tasks[recursiveTaskname]
                        return fmt.Errorf("recursive task on '%s': Task '%s' is recursively need itself", recursiveTask.GetFileLocation(), recursiveTask.GetName())
                }</span>
        }
        <span class="cov7" title="84">return nil</span>
}

func (p *Project) isTaskRecursive(task *Task, previousTaskNames []string) (isRecursive bool, recursiveTaskName string) <span class="cov8" title="181">{
        taskName := task.GetName()
        for _, previousTaskName := range previousTaskNames </span><span class="cov6" title="44">{
                if previousTaskName == taskName </span><span class="cov2" title="2">{
                        return true, taskName
                }</span>
        }
        <span class="cov8" title="179">previousTaskNames = append(previousTaskNames, task.GetName())
        for _, dependencyTaskName := range task.Dependencies </span><span class="cov4" title="11">{
                subTask := p.Tasks[dependencyTaskName]
                if isRecursive, recursiveTaskName := p.isTaskRecursive(subTask, previousTaskNames); isRecursive </span><span class="cov2" title="3">{
                        return true, recursiveTaskName
                }</span>
        }
        <span class="cov8" title="176">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov5" title="27">{
                subTask := p.Tasks[parentTaskName]
                if isRecursive, recursiveTaskName := p.isTaskRecursive(subTask, previousTaskNames); isRecursive </span><span class="cov2" title="3">{
                        return true, recursiveTaskName
                }</span>
        }
        <span class="cov8" title="173">return false, ""</span>
}

func (p *Project) validateTaskDependencies() (err error) <span class="cov7" title="87">{
        for taskName, task := range p.Tasks </span><span class="cov8" title="148">{
                for index, dependencyTaskName := range task.Dependencies </span><span class="cov4" title="9">{
                        if _, dependencyTaskExist := p.Tasks[dependencyTaskName]; !dependencyTaskExist </span><span class="cov1" title="1">{
                                return fmt.Errorf("undeclared task dependency on '%s': Task '%s' is required at tasks[%s][dependencies][%d]", task.GetFileLocation(), dependencyTaskName, taskName, index)
                        }</span>
                }
        }
        <span class="cov7" title="86">return nil</span>
}

func (p *Project) validateTaskExtend() (err error) <span class="cov7" title="90">{
        for taskName, task := range p.Tasks </span><span class="cov8" title="153">{
                if len(task.Extends) &gt; 0 &amp;&amp; task.Extend != "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("redundant key declaration on '%s': Task '%s' has both `extend` and `extends`", task.GetFileLocation(), taskName)
                }</span>
                <span class="cov8" title="152">if task.Extend != "" </span><span class="cov5" title="27">{
                        if _, parentTaskExist := p.Tasks[task.Extend]; !parentTaskExist </span><span class="cov1" title="1">{
                                return fmt.Errorf("undeclared parent task on '%s': Task '%s' is required at tasks[%s][extend]", task.GetFileLocation(), task.Extend, taskName)
                        }</span>
                }
                <span class="cov8" title="151">for index, parentTaskName := range task.Extends </span><span class="cov2" title="2">{
                        if _, parentTaskExist := p.Tasks[parentTaskName]; !parentTaskExist </span><span class="cov1" title="1">{
                                return fmt.Errorf("undeclared parent task on '%s': Task '%s' is required at tasks[%s][extends][%d]", task.GetFileLocation(), parentTaskName, taskName, index)
                        }</span>
                }
        }
        <span class="cov7" title="87">return nil</span>
}

func (p *Project) validateTaskInputs() (err error) <span class="cov7" title="84">{
        for taskName, task := range p.Tasks </span><span class="cov8" title="141">{
                for index, inputName := range task.Inputs </span><span class="cov4" title="9">{
                        if _, inputExist := p.Inputs[inputName]; !inputExist </span><span class="cov1" title="1">{
                                return fmt.Errorf("undeclared input task on '%s': Input '%s' is required at %s[inputs][%d]", task.GetFileLocation(), inputName, taskName, index)
                        }</span>
                }
        }
        <span class="cov7" title="83">return nil</span>
}

func (p *Project) validateTaskEnvRef() (err error) <span class="cov7" title="83">{
        for taskName, task := range p.Tasks </span><span class="cov8" title="140">{
                if len(task.EnvRefs) &gt; 0 &amp;&amp; task.EnvRef != "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("redundant key declaration on '%s': Task '%s' has both `envRef` and `envRefs`", task.GetFileLocation(), taskName)
                }</span>
                <span class="cov8" title="139">if task.EnvRef != "" </span><span class="cov3" title="5">{
                        if _, envRefExist := p.EnvRefMap[task.EnvRef]; !envRefExist </span><span class="cov1" title="1">{
                                return fmt.Errorf("undeclared envRef on '%s': Env '%s' is required at tasks[%s][envRef]", task.GetFileLocation(), task.EnvRef, taskName)
                        }</span>
                }
                <span class="cov8" title="138">for index, envRefName := range task.EnvRefs </span><span class="cov1" title="1">{
                        if _, envRefExist := p.EnvRefMap[envRefName]; !envRefExist </span><span class="cov1" title="1">{
                                return fmt.Errorf("undeclared envRefs on '%s': Env '%s' is required at tasks[%s][envRefs][%d]", task.GetFileLocation(), envRefName, taskName, index)
                        }</span>
                }
        }
        <span class="cov7" title="80">return nil</span>
}

func (p *Project) validateTaskConfigRef() (err error) <span class="cov7" title="80">{
        for taskName, task := range p.Tasks </span><span class="cov8" title="137">{
                if len(task.ConfigRefs) &gt; 0 &amp;&amp; task.ConfigRef != "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("redundant key declaration on '%s': Task '%s' has both `config` and `configRefs`", task.GetFileLocation(), taskName)
                }</span>
                <span class="cov8" title="136">if task.ConfigRef != "" </span><span class="cov3" title="5">{
                        if _, configRefExist := p.ConfigRefMap[task.ConfigRef]; !configRefExist </span><span class="cov1" title="1">{
                                return fmt.Errorf("undeclared configRef on '%s': Config '%s' is required at tasks[%s][configRef]", task.GetFileLocation(), task.ConfigRef, taskName)
                        }</span>
                }
                <span class="cov8" title="135">for index, configRefName := range task.ConfigRefs </span><span class="cov1" title="1">{
                        if _, configRefExist := p.ConfigRefMap[configRefName]; !configRefExist </span><span class="cov1" title="1">{
                                return fmt.Errorf("undeclared configRefs on '%s': Config '%s' is required at tasks[%s][configRefs][%d]", task.GetFileLocation(), configRefName, taskName, index)
                        }</span>
                }
        }
        <span class="cov7" title="77">return nil</span>
}

func (p *Project) cascadeIncludes(d *output.Decoration) (err error) <span class="cov7" title="108">{
        for _, includeLocation := range p.Includes </span><span class="cov4" title="14">{
                parsedIncludeLocation := os.ExpandEnv(includeLocation)
                if !filepath.IsAbs(parsedIncludeLocation) </span><span class="cov4" title="14">{
                        parsedIncludeLocation = filepath.Join(filepath.Dir(p.fileLocation), parsedIncludeLocation)
                }</span>
                <span class="cov4" title="14">includedProject, err := loadProject(d, parsedIncludeLocation, []string{})
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov4" title="13">if err = p.cascadeInputs(parsedIncludeLocation, includedProject); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov4" title="12">if err = p.cascadeTasks(parsedIncludeLocation, includedProject); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov4" title="11">if err = p.cascadeEnvRef(parsedIncludeLocation, includedProject); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov4" title="10">if err = p.cascadeConfigRef(parsedIncludeLocation, includedProject); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov7" title="103">return err</span>
}

func (p *Project) cascadeInputs(parsedIncludeLocation string, includedProject *Project) (err error) <span class="cov4" title="13">{
        for inputName, input := range includedProject.Inputs </span><span class="cov3" title="5">{
                existingInput, inputAlreadyDeclared := p.Inputs[inputName]
                if inputAlreadyDeclared </span><span class="cov2" title="2">{
                        if input.fileLocation == existingInput.fileLocation </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov1" title="1">return fmt.Errorf("redundant input declaration on '%s': Input '%s' was already declared on '%s'", input.fileLocation, inputName, existingInput.fileLocation)</span>
                }
                <span class="cov2" title="3">p.Inputs[inputName] = input</span>
        }
        <span class="cov4" title="12">return nil</span>
}

func (p *Project) cascadeTasks(parsedIncludeLocation string, includedProject *Project) (err error) <span class="cov4" title="12">{
        for taskName, task := range includedProject.Tasks </span><span class="cov5" title="17">{
                existingTask, taskAlreadyDeclared := p.Tasks[taskName]
                if taskAlreadyDeclared </span><span class="cov2" title="2">{
                        if task.fileLocation == existingTask.fileLocation </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov1" title="1">return fmt.Errorf("redundant task declaration on '%s': Task '%s' was already declared on '%s'", task.fileLocation, taskName, existingTask.fileLocation)</span>
                }
                <span class="cov5" title="15">p.Tasks[taskName] = task</span>
        }
        <span class="cov4" title="11">return nil</span>
}

func (p *Project) cascadeEnvRef(parsedIncludeLocation string, includedProject *Project) (err error) <span class="cov4" title="11">{
        for envRefName, envRef := range includedProject.EnvRefMap </span><span class="cov3" title="5">{
                existingEnvRef, envRefAlreadyDeclared := p.EnvRefMap[envRefName]
                if envRefAlreadyDeclared </span><span class="cov2" title="2">{
                        if envRef.fileLocation == existingEnvRef.fileLocation </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov1" title="1">return fmt.Errorf("redundant envs declaration on '%s': Env '%s' was already declared on '%s'", envRef.fileLocation, envRefName, existingEnvRef.fileLocation)</span>
                }
                <span class="cov2" title="3">p.EnvRefMap[envRefName] = envRef</span>
        }
        <span class="cov4" title="10">return nil</span>
}

func (p *Project) cascadeConfigRef(parsedIncludeLocation string, includedProject *Project) (err error) <span class="cov4" title="10">{
        for configRefName, configRef := range includedProject.ConfigRefMap </span><span class="cov3" title="5">{
                existingConfigRef, configRefAlreadyDeclared := p.ConfigRefMap[configRefName]
                if configRefAlreadyDeclared </span><span class="cov2" title="2">{
                        if configRef.fileLocation == existingConfigRef.fileLocation </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov1" title="1">return fmt.Errorf("redundant configs declaration on '%s': Config '%s' was already declared '%s'", configRef.fileLocation, configRefName, existingConfigRef.fileLocation)</span>
                }
                <span class="cov2" title="3">p.ConfigRefMap[configRefName] = configRef</span>
        }
        <span class="cov4" title="9">return nil</span>
}

func (p *Project) generateSessionId() <span class="cov7" title="90">{
        p.sessionId = fmt.Sprintf("%s-%s", p.Util.Str.NewName(), p.Util.Str.NewUUID())
}</span>

func (p *Project) setSortedTaskNames() <span class="cov7" title="90">{
        p.sortedTaskNames = []string{}
        for taskName := range p.Tasks </span><span class="cov8" title="153">{
                p.sortedTaskNames = append(p.sortedTaskNames, taskName)
        }</span>
        <span class="cov7" title="90">sort.Strings(p.sortedTaskNames)</span>
}

func (p *Project) setSortedInputNames() <span class="cov7" title="90">{
        p.sortedInputNames = []string{}
        for inputName := range p.Inputs </span><span class="cov6" title="39">{
                p.sortedInputNames = append(p.sortedInputNames, inputName)
        }</span>
        <span class="cov7" title="90">sort.Strings(p.sortedInputNames)</span>
}

func (p *Project) linkToTasks() <span class="cov7" title="90">{
        for taskName, task := range p.Tasks </span><span class="cov8" title="153">{
                task.Project = p
                task.name = taskName
                task.linkToEnvs()
        }</span>
}

func (p *Project) linkToInputs() <span class="cov7" title="90">{
        for inputName, input := range p.Inputs </span><span class="cov6" title="39">{
                input.Project = p
                input.name = inputName
        }</span>
}

func (p *Project) ProcessOutputWg() <span class="cov0" title="0">{
        p.OutputWgMutex.Lock()
        p.OutputWg.Done()
        p.OutputWgMutex.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package dsl

import (
        "fmt"
        "io/ioutil"
        "strings"

        "github.com/joho/godotenv"
        "github.com/state-alchemists/zaruba/fileutil"
        "github.com/state-alchemists/zaruba/jsonutil"
        "github.com/state-alchemists/zaruba/yamlstyler"
        yaml "gopkg.in/yaml.v3"
)

type ProjectUtil struct {
        file               *fileutil.FileUtil
        Task               *TaskUtil
        locationProjectMap map[string]*Project
}

func NewProjectUtil(fileUtil *fileutil.FileUtil, jsonUtil *jsonutil.JsonUtil) *ProjectUtil <span class="cov10" title="121">{
        taskUtil := NewTaskUtil(fileUtil, jsonUtil)
        projectUtil := &amp;ProjectUtil{
                file:               fileUtil,
                Task:               taskUtil,
                locationProjectMap: map[string]*Project{},
        }
        projectUtil.Task.project = projectUtil
        return projectUtil
}</span>

func (projectUtil *ProjectUtil) getProject(projectFile string) (project *Project, err error) <span class="cov0" title="0">{
        project, exist := projectUtil.locationProjectMap[projectFile]
        if exist </span><span class="cov0" title="0">{
                return project, nil
        }</span>
        <span class="cov0" title="0">project, err = NewDefaultProject(projectFile)
        projectUtil.locationProjectMap[projectFile] = project
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = project.Init()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return project, nil</span>
}

func (projectUtil *ProjectUtil) SetValue(key, newValue, projectFile string) (err error) <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("key cannot be empty")
        }</span>
        <span class="cov0" title="0">if newValue == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("value cannot be empty")
        }</span>
        <span class="cov0" title="0">project, err := projectUtil.getProject(projectFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">oldValue := project.GetValue(key)
        valueFileNames, err := project.GetValueFileNames()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, valueFileName := range valueFileNames </span><span class="cov0" title="0">{
                fileContentB, err := ioutil.ReadFile(valueFileName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">valueMap := map[string]string{}
                if err := yaml.Unmarshal(fileContentB, &amp;valueMap); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">currentValue, exist := valueMap[key]
                if !exist || currentValue == oldValue || strings.HasSuffix(valueFileName, "default.values.yaml") </span><span class="cov0" title="0">{
                        valueMap[key] = newValue
                }</span>
                <span class="cov0" title="0">newFileContentB, err := yaml.Marshal(valueMap)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := ioutil.WriteFile(valueFileName, newFileContentB, 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (projectUtil *ProjectUtil) IncludeFile(fileName string, projectFilePath string) (err error) <span class="cov0" title="0">{
        node, err := projectUtil.file.ReadYamlNode(projectFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">docNode := node.Content[0]
        // declare new includeVal
        newIncludeVal := &amp;yaml.Node{Kind: yaml.ScalarNode, Value: fileName}
        // look for "includes"
        for index := 0; index &lt; len(docNode.Content); index += 2 </span><span class="cov0" title="0">{
                keyNode := docNode.Content[index]
                valNode := docNode.Content[index+1]
                if keyNode.Value == "includes" &amp;&amp; valNode.ShortTag() == "!!seq" </span><span class="cov0" title="0">{
                        valNode.Style = yaml.LiteralStyle
                        valNode.Content = append(valNode.Content, newIncludeVal)
                        return projectUtil.file.WriteYamlNode(projectFilePath, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})
                }</span>
        }
        <span class="cov0" title="0">includesKey := &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "includes"}
        includesVal := &amp;yaml.Node{Kind: yaml.SequenceNode, Content: []*yaml.Node{newIncludeVal}}
        docNode.Style = yaml.LiteralStyle
        docNode.Content = append(
                []*yaml.Node{includesKey, includesVal},
                docNode.Content...,
        )
        return projectUtil.file.WriteYamlNode(projectFilePath, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})</span>
}

func (projectUtil *ProjectUtil) AddTaskIfNotExist(taskName string, taskFilePath string) (err error) <span class="cov0" title="0">{
        node, err := projectUtil.file.ReadYamlNode(taskFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">docNode := node.Content[0]
        // declare newTaskName node and newTask node
        newTaskName := &amp;yaml.Node{Kind: yaml.ScalarNode, Value: taskName}
        newTask := &amp;yaml.Node{Kind: yaml.MappingNode}
        // look for "tasks"
        for index := 0; index &lt; len(docNode.Content); index += 2 </span><span class="cov0" title="0">{
                keyNode := docNode.Content[index]
                valNode := docNode.Content[index+1]
                if keyNode.Value == "tasks" &amp;&amp; valNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                        for taskNameIndex := 0; taskNameIndex &lt; len(valNode.Content); taskNameIndex += 2 </span><span class="cov0" title="0">{
                                if valNode.Content[taskNameIndex].Value == taskName </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        }
                        <span class="cov0" title="0">valNode.Style = yaml.LiteralStyle
                        valNode.Content = append(valNode.Content, newTaskName, newTask)
                        return projectUtil.file.WriteYamlNode(taskFilePath, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})</span>
                }
        }
        // "tasks" not found, add it
        <span class="cov0" title="0">docNode.Style = yaml.LiteralStyle
        docNode.Content = append(
                []*yaml.Node{
                        {Kind: yaml.ScalarNode, Value: "tasks"},
                        {
                                Kind: yaml.MappingNode, Content: []*yaml.Node{
                                        newTaskName, newTask,
                                },
                        },
                },
                docNode.Content...,
        )
        return projectUtil.file.WriteYamlNode(taskFilePath, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})</span>
}

func (projectUtil *ProjectUtil) SyncEnvFiles(projectFile string) (err error) <span class="cov0" title="0">{
        project, err := projectUtil.getProject(projectFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">envFileNames, err := project.GetEnvFileNames()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, envFileName := range envFileNames </span><span class="cov0" title="0">{
                fileEnvMap, err := godotenv.Read(envFileName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, task := range project.Tasks </span><span class="cov0" title="0">{
                        for _, envKey := range task.GetEnvKeys() </span><span class="cov0" title="0">{
                                envObj, declared := task.GetEnvObject(envKey)
                                if !declared </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">envFrom := envObj.From
                                if envFrom == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if _, keyExist := fileEnvMap[envFrom]; keyExist </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">envDefault := envObj.Default
                                fileEnvMap[envFrom] = envDefault</span>
                        }
                }
                <span class="cov0" title="0">godotenv.Write(fileEnvMap, envFileName)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (projectUtil *ProjectUtil) SyncTasksEnv(projectFile string) (err error) <span class="cov0" title="0">{
        project, err := projectUtil.getProject(projectFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, task := range project.Tasks </span><span class="cov0" title="0">{
                taskName := task.GetName()
                err := projectUtil.Task.Env.Sync(taskName, projectFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package dsl

import (
        "fmt"
        "os"
        "path/filepath"
)

func SetDefaultEnv() <span class="cov10" title="107">{
        executable, _ := os.Executable()
        if os.Getenv("ZARUBA_HOME") == "" </span><span class="cov1" title="1">{
                os.Setenv("ZARUBA_HOME", filepath.Dir(executable))
        }</span>
        <span class="cov10" title="107">if os.Getenv("ZARUBA_BIN") == "" </span><span class="cov0" title="0">{
                os.Setenv("ZARUBA_BIN", executable)
        }</span>
        <span class="cov10" title="107">if os.Getenv("ZARUBA_SHELL") == "" </span><span class="cov0" title="0">{
                os.Setenv("ZARUBA_SHELL", "bash")
        }</span>
        <span class="cov10" title="107">if os.Getenv("ZARUBA_SCRIPTS") == "" </span><span class="cov10" title="107">{
                os.Setenv("ZARUBA_SCRIPTS", "")
        }</span>
        <span class="cov10" title="107">if os.Getenv("ZARUBA_DECORATION") == "" </span><span class="cov0" title="0">{
                os.Setenv("ZARUBA_DECORATION", "default")
        }</span>
        <span class="cov10" title="107">if os.Getenv("ZARUBA_LOG_TIME") == "" </span><span class="cov0" title="0">{
                os.Setenv("ZARUBA_LOG_TIME", "true")
        }</span>
        <span class="cov10" title="107">if os.Getenv("ZARUBA_LOG_STATUS_TIME_INTERVAL") == "" </span><span class="cov0" title="0">{
                os.Setenv("ZARUBA_LOG_STATUS_TIME_INTERVAL", "5m")
        }</span>
        <span class="cov10" title="107">if os.Getenv("ZARUBA_LOG_STATUS_LINE_INTERVAL") == "" </span><span class="cov0" title="0">{
                os.Setenv("ZARUBA_LOG_STATUS_LINE_INTERVAL", "40")
        }</span>
        <span class="cov10" title="107">if os.Getenv("ZARUBA_ENV") == "" </span><span class="cov10" title="107">{
                os.Setenv("ZARUBA_ENV", "")
        }</span>
        <span class="cov10" title="107">if os.Getenv("ZARUBA_MAX_LOG_FILE_SIZE") == "" </span><span class="cov0" title="0">{
                os.Setenv("ZARUBA_MAX_LOG_FILE_SIZE", fmt.Sprintf("%d", 5*1024*1024))
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package dsl

import (
        "bufio"
        "bytes"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "syscall"
        "text/template"
        "time"
)

// Task is zaruba task
type Task struct {
        Start                   []string          `yaml:"start,omitempty"`
        MaxStartRetryStr        string            `yaml:"maxStartRetry,omitempty"`
        StartRetryDelayStr      string            `yaml:"startRetryDelay,omitempty"`
        Check                   []string          `yaml:"check,omitempty"`
        MaxCheckRetryStr        string            `yaml:"maxCheckRetry,omitempty"`
        CheckRetryDelayStr      string            `yaml:"checkRetryDelay,omitempty"`
        TimeoutStr              string            `yaml:"timeout,omitempty"`
        Private                 bool              `yaml:"private,omitempty"`
        AutoTerminateStr        string            `yaml:"autoTerminate,omitempty"`
        Extend                  string            `yaml:"extend,omitempty"`
        Extends                 []string          `yaml:"extends,omitempty"`
        Location                string            `yaml:"location,omitempty"`
        ConfigRef               string            `yaml:"configRef,omitempty"`
        ConfigRefs              []string          `yaml:"configRefs,omitempty"`
        Configs                 map[string]string `yaml:"configs,omitempty"`
        EnvRef                  string            `yaml:"envRef,omitempty"`
        EnvRefs                 []string          `yaml:"envRefs,omitempty"`
        Envs                    map[string]*Env   `yaml:"envs,omitempty"`
        Dependencies            []string          `yaml:"dependencies,omitempty"`
        Inputs                  []string          `yaml:"inputs,omitempty"`
        Description             string            `yaml:"description,omitempty"`
        Icon                    string            `yaml:"icon,omitempty"`
        SaveLog                 string            `yaml:"saveLog,omitempty"`
        SyncEnv                 string            `yaml:"syncEnv,omitempty"`
        SyncEnvLocation         string            `yaml:"syncEnvLocation,omitempty"`
        Project                 *Project          `yaml:"_project,omitempty"`
        fileLocation            string            // File location where this task was declared
        uuid                    string            // Unique identifier of current task
        name                    string            // Current task name
        generatedRandomName     string            // Random name
        logPrefix               string            // Task prefix for logging
        timeoutDuration         time.Duration
        startRetry              int
        startRetryDelayDuration time.Duration
        checkRetry              int
        checkRetryDelayDuration time.Duration
        tpl                     *Tpl
        maxRecursiveLevel       int
        currentRecursiveLevel   int
        color                   string
        icon                    string
        isIconGenerated         bool
}

func (task *Task) init() <span class="cov7" title="134">{
        task.isIconGenerated = false
        task.maxRecursiveLevel = 100
        task.currentRecursiveLevel = 0
        task.generateIcon()
        task.generateColor()
        task.generateLogPrefix()
        task.generateUUID()
        task.generateGeneratedRandomName()
}</span>

func (task *Task) GetUUID() (uuid string) <span class="cov7" title="133">{
        return task.uuid
}</span>

func (task *Task) GetGeneratedRandomName() (name string) <span class="cov7" title="133">{
        return task.generatedRandomName
}</span>

func (task *Task) GetName() (name string) <span class="cov9" title="935">{
        return task.name
}</span>

func (task *Task) GetColor() (color string) <span class="cov0" title="0">{
        return task.color
}</span>

func (task *Task) GetIcon() (icon string) <span class="cov0" title="0">{
        return task.icon
}</span>

func (task *Task) GetDecoratedIcon() (decoratedIcon string) <span class="cov7" title="134">{
        return task.Project.Decoration.Icon(task.icon)
}</span>

func (task *Task) getDefaultMaxStartRetry() int <span class="cov0" title="0">{
        return 3
}</span>

func (task *Task) getMaxStartRetry() int <span class="cov0" title="0">{
        startRetry, err := strconv.Atoi(task.MaxStartRetryStr)
        if err == nil </span><span class="cov0" title="0">{
                return startRetry
        }</span>
        <span class="cov0" title="0">parentTaskNames := task.GetParentTaskNames()
        if len(parentTaskNames) &gt; 0 </span><span class="cov0" title="0">{
                parentTaskName := parentTaskNames[0]
                parentTask := task.Project.Tasks[parentTaskName]
                parentStartRetry := parentTask.getMaxStartRetry()
                if parentStartRetry &gt; 0 </span><span class="cov0" title="0">{
                        return parentStartRetry
                }</span>
        }
        <span class="cov0" title="0">return task.getDefaultMaxStartRetry()</span>
}

func (task *Task) GetMaxStartRetry() int <span class="cov0" title="0">{
        if task.startRetry &gt; 0 </span><span class="cov0" title="0">{
                return task.startRetry
        }</span>
        <span class="cov0" title="0">startRetry := task.getMaxStartRetry()
        if startRetry &lt;= 0 </span><span class="cov0" title="0">{
                startRetry = task.getDefaultMaxStartRetry()
        }</span>
        <span class="cov0" title="0">task.startRetry = startRetry
        return startRetry</span>
}

func (task *Task) getDefaultStartRetryDelayDuration() time.Duration <span class="cov0" title="0">{
        return 1 * time.Second
}</span>

func (task *Task) getStartRetryDelayDuration() time.Duration <span class="cov0" title="0">{
        startRetryDelayDuration, err := time.ParseDuration(task.StartRetryDelayStr)
        if err == nil </span><span class="cov0" title="0">{
                return startRetryDelayDuration
        }</span>
        <span class="cov0" title="0">parentTaskNames := task.GetParentTaskNames()
        if len(parentTaskNames) &gt; 0 </span><span class="cov0" title="0">{
                parentTaskName := parentTaskNames[0]
                parentTask := task.Project.Tasks[parentTaskName]
                parentStartRetryDelayDuration := parentTask.getStartRetryDelayDuration()
                if parentStartRetryDelayDuration &gt; 0 </span><span class="cov0" title="0">{
                        return parentStartRetryDelayDuration
                }</span>
        }
        <span class="cov0" title="0">return task.getDefaultStartRetryDelayDuration()</span>
}

func (task *Task) GetStartRetryDelayDuration() time.Duration <span class="cov0" title="0">{
        if task.startRetryDelayDuration &gt; 0 </span><span class="cov0" title="0">{
                return task.startRetryDelayDuration
        }</span>
        <span class="cov0" title="0">startRetryDelayDuration := task.getStartRetryDelayDuration()
        if startRetryDelayDuration &lt; 0 </span><span class="cov0" title="0">{
                startRetryDelayDuration = task.getDefaultStartRetryDelayDuration()
        }</span>
        <span class="cov0" title="0">task.startRetryDelayDuration = startRetryDelayDuration
        return startRetryDelayDuration</span>
}

func (task *Task) getDefaultMaxCheckRetry() int <span class="cov0" title="0">{
        // 0 means infinite
        return 0
}</span>

func (task *Task) getMaxCheckRetry() int <span class="cov0" title="0">{
        checkRetry, err := strconv.Atoi(task.MaxCheckRetryStr)
        if err == nil </span><span class="cov0" title="0">{
                return checkRetry
        }</span>
        <span class="cov0" title="0">parentTaskNames := task.GetParentTaskNames()
        if len(parentTaskNames) &gt; 0 </span><span class="cov0" title="0">{
                parentTaskName := parentTaskNames[0]
                parentTask := task.Project.Tasks[parentTaskName]
                parentCheckRetry := parentTask.getMaxCheckRetry()
                if parentCheckRetry &gt; 0 </span><span class="cov0" title="0">{
                        return parentCheckRetry
                }</span>
        }
        <span class="cov0" title="0">return task.getDefaultMaxCheckRetry()</span>
}

func (task *Task) GetMaxCheckRetry() int <span class="cov0" title="0">{
        if task.checkRetry &gt; 0 </span><span class="cov0" title="0">{
                return task.checkRetry
        }</span>
        <span class="cov0" title="0">checkRetry := task.getMaxCheckRetry()
        if checkRetry &lt; 0 </span><span class="cov0" title="0">{
                checkRetry = task.getDefaultMaxCheckRetry()
        }</span>
        <span class="cov0" title="0">task.checkRetry = checkRetry
        return checkRetry</span>
}

func (task *Task) getDefaultCheckRetryDelayDuration() time.Duration <span class="cov0" title="0">{
        return 1 * time.Second
}</span>

func (task *Task) getCheckRetryDelayDuration() time.Duration <span class="cov0" title="0">{
        checkRetryDelayDuration, err := time.ParseDuration(task.CheckRetryDelayStr)
        if err == nil </span><span class="cov0" title="0">{
                return checkRetryDelayDuration
        }</span>
        <span class="cov0" title="0">parentTaskNames := task.GetParentTaskNames()
        if len(parentTaskNames) &gt; 0 </span><span class="cov0" title="0">{
                parentTaskName := parentTaskNames[0]
                parentTask := task.Project.Tasks[parentTaskName]
                parentCheckRetryDelayDuration := parentTask.getCheckRetryDelayDuration()
                if parentCheckRetryDelayDuration &gt; 0 </span><span class="cov0" title="0">{
                        return parentCheckRetryDelayDuration
                }</span>
        }
        <span class="cov0" title="0">return task.getDefaultCheckRetryDelayDuration()</span>
}

func (task *Task) GetCheckRetryDelayDuration() time.Duration <span class="cov0" title="0">{
        if task.checkRetryDelayDuration &gt; 0 </span><span class="cov0" title="0">{
                return task.checkRetryDelayDuration
        }</span>
        <span class="cov0" title="0">checkRetryDelayDuration := task.getCheckRetryDelayDuration()
        if checkRetryDelayDuration &lt; 0 </span><span class="cov0" title="0">{
                checkRetryDelayDuration = task.getDefaultCheckRetryDelayDuration()
        }</span>
        <span class="cov0" title="0">task.checkRetryDelayDuration = checkRetryDelayDuration
        return checkRetryDelayDuration</span>
}

func (task *Task) getTimeoutDuration() time.Duration <span class="cov1" title="1">{
        timeoutDuration, err := time.ParseDuration(task.TimeoutStr)
        if err == nil </span><span class="cov1" title="1">{
                return timeoutDuration
        }</span>
        <span class="cov0" title="0">parentTaskNames := task.GetParentTaskNames()
        if len(parentTaskNames) &gt; 0 </span><span class="cov0" title="0">{
                parentTaskName := parentTaskNames[0]
                parentTask := task.Project.Tasks[parentTaskName]
                parentTimeoutDuration := parentTask.getTimeoutDuration()
                if parentTimeoutDuration &gt; 0 </span><span class="cov0" title="0">{
                        return parentTimeoutDuration
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (task *Task) GetTimeoutDuration() time.Duration <span class="cov1" title="1">{
        if task.timeoutDuration &gt; 0 </span><span class="cov0" title="0">{
                return task.timeoutDuration
        }</span>
        <span class="cov1" title="1">timeoutDuration := task.getTimeoutDuration()
        if timeoutDuration &lt;= 0 </span><span class="cov0" title="0">{
                timeoutDuration = 10 * time.Minute
        }</span>
        <span class="cov1" title="1">task.timeoutDuration = timeoutDuration
        return timeoutDuration</span>
}

func (task *Task) GetFileLocation() (fileLocation string) <span class="cov7" title="146">{
        return task.fileLocation
}</span>

func (task *Task) GetDirPath() (dirPath string) <span class="cov8" title="284">{
        if task.fileLocation == "" </span><span class="cov0" title="0">{
                dirPath, _ = os.Getwd()
                return dirPath
        }</span>
        <span class="cov8" title="284">return filepath.Dir(task.fileLocation)</span>
}

func (task *Task) GetLocation() (path string) <span class="cov8" title="518">{
        if task.Location != "" </span><span class="cov3" title="10">{
                return filepath.Join(filepath.Dir(task.fileLocation), task.Location)
        }</span>
        <span class="cov8" title="508">parentTaskNames := task.GetParentTaskNames()
        if len(parentTaskNames) &gt; 0 </span><span class="cov7" title="223">{
                parentTaskName := parentTaskNames[0]
                parentTask := task.Project.Tasks[parentTaskName]
                parentTaskLocation := parentTask.GetLocation()
                if parentTaskLocation != "" </span><span class="cov1" title="1">{
                        return parentTaskLocation
                }</span>
        }
        <span class="cov8" title="507">return ""</span>
}

func (task *Task) GetIsSaveLog() bool <span class="cov4" title="18">{
        if task.Project.Util.Bool.IsFalse(task.SaveLog) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="18">parentTaskNames := task.GetParentTaskNames()
        if len(parentTaskNames) &gt; 0 </span><span class="cov2" title="4">{
                parentTaskName := parentTaskNames[0]
                parentTask := task.Project.Tasks[parentTaskName]
                if parentTask.GetIsSaveLog() </span><span class="cov2" title="4">{
                        return true
                }</span>
        }
        <span class="cov4" title="14">return true</span>
}

func (task *Task) GetShouldSyncEnv() bool <span class="cov0" title="0">{
        if task.Project.Util.Bool.IsFalse(task.SyncEnv) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if task.Project.Util.Bool.IsTrue(task.SyncEnv) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">parentTaskNames := task.GetParentTaskNames()
        if len(parentTaskNames) &gt; 0 </span><span class="cov0" title="0">{
                parentTaskName := parentTaskNames[0]
                parentTask := task.Project.Tasks[parentTaskName]
                if parentTask.GetShouldSyncEnv() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (task *Task) GetSyncEnvLocation() (path string) <span class="cov0" title="0">{
        if task.SyncEnvLocation != "" </span><span class="cov0" title="0">{
                return filepath.Join(filepath.Dir(task.fileLocation), task.SyncEnvLocation)
        }</span>
        <span class="cov0" title="0">parentTaskNames := task.GetParentTaskNames()
        if len(parentTaskNames) &gt; 0 </span><span class="cov0" title="0">{
                parentTaskName := parentTaskNames[0]
                parentTask := task.Project.Tasks[parentTaskName]
                parentTaskSyncEnvLocation := parentTask.GetSyncEnvLocation()
                if parentTaskSyncEnvLocation != "" </span><span class="cov0" title="0">{
                        return parentTaskSyncEnvLocation
                }</span>
        }
        <span class="cov0" title="0">return task.GetLocation()</span>
}

func (task *Task) GetWorkPath() (workPath string) <span class="cov8" title="295">{
        if taskLocation := task.GetLocation(); taskLocation != "" </span><span class="cov3" title="10">{
                return taskLocation
        }</span>
        <span class="cov8" title="285">workPath, _ = os.Getwd()
        return workPath</span>
}

func (task *Task) GetAutoTerminate() (autoTerminate bool) <span class="cov7" title="158">{
        if task.Project.Util.Bool.IsTrue(task.AutoTerminateStr) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov7" title="158">if task.Project.Util.Bool.IsFalse(task.AutoTerminateStr) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov7" title="158">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov4" title="24">{
                parentTask := task.Project.Tasks[parentTaskName]
                if parentTask.GetAutoTerminate() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov7" title="158">return false</span>
}

func (task *Task) IsHavingStartCmd() bool <span class="cov5" title="32">{
        if len(task.Start) &gt; 0 </span><span class="cov4" title="22">{
                return true
        }</span>
        <span class="cov3" title="10">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov3" title="5">{
                parentTask := task.Project.Tasks[parentTaskName]
                if parentTask.IsHavingStartCmd() </span><span class="cov3" title="5">{
                        return true
                }</span>
        }
        <span class="cov3" title="5">return false</span>
}

func (task *Task) IsHavingCheckCmd() bool <span class="cov7" title="180">{
        if len(task.Check) &gt; 0 </span><span class="cov5" title="33">{
                return true
        }</span>
        <span class="cov7" title="147">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov5" title="29">{
                parentTask := task.Project.Tasks[parentTaskName]
                if parentTask.IsHavingCheckCmd() </span><span class="cov4" title="12">{
                        return true
                }</span>
        }
        <span class="cov7" title="135">return false</span>
}

func (task *Task) GetValue(keys ...string) (val string, err error) <span class="cov3" title="5">{
        key := strings.Join(keys, "::")
        pattern, exist := task.Project.GetValue(key), task.Project.IsValueExist(key)
        if !exist </span><span class="cov1" title="1">{
                return "", nil
        }</span>
        <span class="cov2" title="4">templateName := fmt.Sprintf("%s[values][%s]", task.GetName(), key)
        return task.getParsedPattern(templateName, pattern)</span>
}

func (task *Task) GetValueKeys() (keys []string) <span class="cov1" title="2">{
        keys = []string{}
        for key := range task.Project.values </span><span class="cov2" title="4">{
                keys = append(keys, key)
        }</span>
        <span class="cov1" title="2">return keys</span>
}

func (task *Task) GetConfigs(keyPattern string) (parsedConfig map[string]string, err error) <span class="cov0" title="0">{
        parsedConfig = map[string]string{}
        for _, key := range task.GetConfigKeys() </span><span class="cov0" title="0">{
                match, err := regexp.MatchString(keyPattern, key)
                if err != nil </span><span class="cov0" title="0">{
                        return parsedConfig, err
                }</span>
                <span class="cov0" title="0">if !match </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">parsedConfig[key], err = task.GetConfig(key)
                if err != nil </span><span class="cov0" title="0">{
                        return parsedConfig, err
                }</span>
        }
        <span class="cov0" title="0">return parsedConfig, nil</span>
}

func (task *Task) GetConfig(key string) (val string, err error) <span class="cov6" title="113">{
        if pattern, declared := task.GetConfigPattern(key); declared </span><span class="cov6" title="112">{
                templateName := fmt.Sprintf("%s[config][%s]", task.GetName(), key)
                return task.getParsedPattern(templateName, pattern)
        }</span>
        <span class="cov1" title="1">return "", nil</span>
}

func (task *Task) GetConfigKeys() (keys []string) <span class="cov7" title="267">{
        keys = []string{}
        for key := range task.Configs </span><span class="cov7" title="224">{
                keys = append(keys, key)
        }</span>
        <span class="cov7" title="267">for _, envRefName := range task.getConfigRefKeys() </span><span class="cov3" title="5">{
                for key := range task.Project.ConfigRefMap[envRefName].Map </span><span class="cov3" title="5">{
                        keys = append(keys, key)
                }</span>
        }
        <span class="cov7" title="267">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov6" title="115">{
                parentTask := task.Project.Tasks[parentTaskName]
                parentKeys := parentTask.GetConfigKeys()
                keys = append(keys, parentKeys...)
        }</span>
        <span class="cov7" title="267">return task.getUniqueElements(keys)</span>
}

func (task *Task) GetConfigPattern(key string) (pattern string, declared bool) <span class="cov7" title="171">{
        if pattern, declared = task.Configs[key]; declared </span><span class="cov6" title="113">{
                return pattern, true
        }</span>
        <span class="cov6" title="58">for _, configRefName := range task.getConfigRefKeys() </span><span class="cov3" title="6">{
                projectBaseConfig := task.Project.ConfigRefMap[configRefName]
                if pattern, declared = projectBaseConfig.Map[key]; declared </span><span class="cov1" title="2">{
                        return pattern, true
                }</span>
        }
        <span class="cov6" title="56">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov5" title="54">{
                parentTask := task.Project.Tasks[parentTaskName]
                if pattern, declared = parentTask.GetConfigPattern(key); declared </span><span class="cov5" title="52">{
                        return pattern, true
                }</span>
        }
        <span class="cov2" title="4">return "", false</span>
}

func (task *Task) GetEnvs() (parsedEnv map[string]string, err error) <span class="cov3" title="11">{
        parsedEnv = map[string]string{}
        for _, key := range task.GetEnvKeys() </span><span class="cov3" title="8">{
                parsedEnv[key], err = task.GetEnv(key)
                if err != nil </span><span class="cov1" title="2">{
                        return parsedEnv, err
                }</span>
        }
        <span class="cov3" title="9">return parsedEnv, nil</span>
}

func (task *Task) GetEnv(key string) (val string, err error) <span class="cov4" title="14">{
        if env, declared := task.GetEnvObject(key); declared </span><span class="cov4" title="13">{
                if env.From != "" </span><span class="cov3" title="6">{
                        if val = os.Getenv(env.From); val != "" </span><span class="cov1" title="2">{
                                return val, nil
                        }</span>
                }
                <span class="cov3" title="11">templateNamePrefix := fmt.Sprintf("%s[env][%s]", task.GetName(), key)
                return task.getParsedPattern(templateNamePrefix, env.Default)</span>
        }
        <span class="cov1" title="1">return os.Getenv(key), nil</span>
}

func (task *Task) GetEnvKeys() (keys []string) <span class="cov4" title="16">{
        keys = []string{}
        for key := range task.Envs </span><span class="cov3" title="9">{
                keys = append(keys, key)
        }</span>
        <span class="cov4" title="16">for _, envRefName := range task.getEnvRefKeys() </span><span class="cov1" title="2">{
                for key := range task.Project.EnvRefMap[envRefName].Map </span><span class="cov1" title="2">{
                        keys = append(keys, key)
                }</span>
        }
        <span class="cov4" title="16">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov2" title="4">{
                parentTask := task.Project.Tasks[parentTaskName]
                parentKeys := parentTask.GetEnvKeys()
                keys = append(keys, parentKeys...)
        }</span>
        <span class="cov4" title="16">return task.getUniqueElements(keys)</span>
}

func (task *Task) GetEnvObject(key string) (env *Env, declared bool) <span class="cov4" title="17">{
        if env, declared = task.Envs[key]; declared </span><span class="cov3" title="11">{
                return env, declared
        }</span>
        <span class="cov3" title="6">for _, envRefName := range task.getEnvRefKeys() </span><span class="cov3" title="5">{
                projectBaseEnv := task.Project.EnvRefMap[envRefName]
                if envObject, declared := projectBaseEnv.Map[key]; declared </span><span class="cov1" title="2">{
                        return &amp;Env{From: envObject.From, Default: envObject.Default}, true
                }</span>
        }
        <span class="cov2" title="4">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov2" title="3">{
                parentTask := task.Project.Tasks[parentTaskName]
                if env, declared = parentTask.GetEnvObject(key); declared </span><span class="cov1" title="2">{
                        return env, true
                }</span>
        }
        <span class="cov1" title="2">return nil, false</span>
}

func (task *Task) GetFirstEnvRefName() (envRefName string) <span class="cov0" title="0">{
        if task.EnvRef != "" </span><span class="cov0" title="0">{
                return task.EnvRef
        }</span>
        <span class="cov0" title="0">if len(task.EnvRefs) &gt; 0 </span><span class="cov0" title="0">{
                return task.EnvRefs[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (task *Task) GetFirstConfigRefName() (configRefName string) <span class="cov0" title="0">{
        if task.ConfigRef != "" </span><span class="cov0" title="0">{
                return task.ConfigRef
        }</span>
        <span class="cov0" title="0">if len(task.ConfigRefs) &gt; 0 </span><span class="cov0" title="0">{
                return task.ConfigRefs[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (task *Task) GetParentTaskNames() (parentTaskNames []string) <span class="cov10" title="1369">{
        if task.Extend != "" </span><span class="cov8" title="489">{
                return []string{task.Extend}
        }</span>
        <span class="cov9" title="880">return task.Extends</span>
}

func (task *Task) getConfigRefKeys() (parentTaskNames []string) <span class="cov8" title="325">{
        if task.ConfigRef != "" </span><span class="cov3" title="11">{
                return []string{task.ConfigRef}
        }</span>
        <span class="cov8" title="314">return task.ConfigRefs</span>
}

func (task *Task) getEnvRefKeys() (parentTaskNames []string) <span class="cov4" title="22">{
        if task.EnvRef != "" </span><span class="cov3" title="7">{
                return []string{task.EnvRef}
        }</span>
        <span class="cov4" title="15">return task.EnvRefs</span>
}

func (task *Task) getParsedPattern(templateNamePrefix, pattern string) (result string, err error) <span class="cov7" title="145">{
        if task.currentRecursiveLevel &gt;= task.maxRecursiveLevel </span><span class="cov1" title="1">{
                return "", fmt.Errorf("max recursive parsing on %s: %s", templateNamePrefix, pattern)
        }</span>
        <span class="cov7" title="144">defaultEnvMap, err := task.getRuntimeEnvMap(true)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="144">for key, val := range defaultEnvMap </span><span class="cov9" title="657">{
                pattern = strings.ReplaceAll(pattern, fmt.Sprintf("${%s}", key), val)
                pattern = strings.ReplaceAll(pattern, fmt.Sprintf("$%s", key), val)
        }</span>
        <span class="cov7" title="144">if task.tpl == nil </span><span class="cov6" title="122">{
                task.tpl = NewTpl(task)
        }</span>
        <span class="cov7" title="144">templateName := task.getTemplateName(templateNamePrefix, pattern)
        tmpl, err := template.New(templateName).Option("missingkey=zero").Parse(pattern)
        if err != nil </span><span class="cov2" title="4">{
                return "", err
        }</span>
        <span class="cov7" title="140">var b bytes.Buffer
        if err = tmpl.Execute(&amp;b, task.tpl); err != nil </span><span class="cov6" title="100">{
                return "", err
        }</span>
        <span class="cov5" title="40">result = b.String()
        return result, nil</span>
}

func (task *Task) getTemplateName(templateNamePrefix, pattern string) (templateName string) <span class="cov7" title="144">{
        lines := strings.Split(pattern, "\n")
        if len(lines) == 2 &amp;&amp; lines[1] == "" </span><span class="cov1" title="1">{
                lines = []string{lines[0]}
        }</span>
        <span class="cov7" title="144">if len(lines) &gt; 1 </span><span class="cov1" title="1">{
                for index, line := range lines </span><span class="cov2" title="3">{
                        lines[index] = fmt.Sprintf("%s | %s", fmt.Sprintf("%4d", index+1), line)
                }</span>
        }
        <span class="cov7" title="144">return fmt.Sprintf("\n%s:\n%s\n", templateNamePrefix, strings.Join(lines, "\n"))</span>
}

func (task *Task) linkToEnvs() <span class="cov7" title="153">{
        for _, env := range task.Envs </span><span class="cov4" title="20">{
                env.Task = task
        }</span>
}

func (task *Task) generateIcon() <span class="cov7" title="134">{
        if !task.isIconGenerated </span><span class="cov7" title="134">{
                task.icon = task.Icon
                if task.icon == "" </span><span class="cov7" title="134">{
                        task.icon = task.Project.Decoration.GenerateIcon()
                }</span>
                <span class="cov7" title="134">task.isIconGenerated = true</span>
        }
}

func (task *Task) generateUUID() <span class="cov7" title="134">{
        if task.uuid == "" </span><span class="cov7" title="134">{
                task.uuid = task.Project.Util.Str.NewUUID()
        }</span>
}

func (task *Task) generateGeneratedRandomName() <span class="cov7" title="134">{
        if task.generatedRandomName == "" </span><span class="cov7" title="134">{
                task.generatedRandomName = task.Project.Util.Str.NewName()
        }</span>
}

func (task *Task) generateColor() <span class="cov7" title="134">{
        if task.color == "" </span><span class="cov7" title="134">{
                d := task.Project.Decoration
                color := d.Faint
                if !task.Private </span><span class="cov7" title="133">{
                        color = d.GenerateColor()
                }</span>
                <span class="cov7" title="134">task.color = color</span>
        }
}

func (task *Task) generateLogPrefix() <span class="cov7" title="134">{
        logTaskName := task.GetName()
        if len(logTaskName) &gt; task.Project.maxPublishedTaskNameLength </span><span class="cov4" title="12">{
                strLen := task.Project.maxPublishedTaskNameLength - 3
                logTaskName = logTaskName[:strLen] + "..."
        }</span> else<span class="cov6" title="122"> {
                repeat := task.Project.maxPublishedTaskNameLength - len(logTaskName)
                logTaskName = logTaskName + strings.Repeat(" ", repeat)
        }</span>
        <span class="cov7" title="134">d := task.Project.Decoration
        task.logPrefix = fmt.Sprintf("%s %s%s%s", task.GetDecoratedIcon(), task.color, logTaskName, d.Normal)</span>
}

func (task *Task) GetDependencies() (dependencies []string) <span class="cov1" title="1">{
        dependencies = task.getDependencies()
        sort.Strings(dependencies)
        return dependencies
}</span>

func (task *Task) getDependencies() (dependencies []string) <span class="cov3" title="5">{
        seen := map[string]bool{}
        for _, dependency := range task.Dependencies </span><span class="cov2" title="3">{
                seen[dependency] = true
        }</span>
        <span class="cov3" title="5">dependencies = append([]string{}, task.Dependencies...)
        for _, dependencyTaskName := range dependencies </span><span class="cov2" title="3">{
                subDependencies := task.Project.Tasks[dependencyTaskName].getDependencies()
                for _, subDependency := range subDependencies </span><span class="cov1" title="1">{
                        if !seen[subDependency] </span><span class="cov1" title="1">{
                                dependencies = append(dependencies, subDependency)
                                seen[subDependency] = true
                        }</span>
                }
        }
        <span class="cov3" title="5">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov1" title="1">{
                subDependencies := task.Project.Tasks[parentTaskName].getDependencies()
                for _, subDependency := range subDependencies </span><span class="cov1" title="2">{
                        if !seen[subDependency] </span><span class="cov1" title="2">{
                                dependencies = append(dependencies, subDependency)
                                seen[subDependency] = true
                        }</span>
                }
        }
        <span class="cov3" title="5">return dependencies</span>
}

func (task *Task) GetStartCmd() (cmd *exec.Cmd, err error) <span class="cov3" title="8">{
        cmdPatterns, err := task.GetStartCmdPatterns()
        if err != nil </span><span class="cov1" title="1">{
                return cmd, err
        }</span>
        <span class="cov3" title="7">cmd, err = task.getCmd("START", cmdPatterns)
        return cmd, err</span>
}

func (task *Task) GetStartCmdPatterns() (cmdPatterns []string, err error) <span class="cov4" title="13">{
        if !task.IsHavingStartCmd() </span><span class="cov1" title="2">{
                return cmdPatterns, fmt.Errorf("cannot retrieve start cmd from any parent task of %s", task.GetName())
        }</span>
        <span class="cov3" title="11">if len(task.Start) &gt; 0 </span><span class="cov3" title="9">{
                return task.Start, nil
        }</span>
        <span class="cov1" title="2">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov1" title="2">{
                parentTask := task.Project.Tasks[parentTaskName]
                cmdPatterns, err = parentTask.GetStartCmdPatterns()
                if err != nil </span><span class="cov0" title="0">{
                        return cmdPatterns, err
                }</span>
        }
        <span class="cov1" title="2">return cmdPatterns, err</span>
}

func (task *Task) GetCheckCmd() (cmd *exec.Cmd, err error) <span class="cov2" title="3">{
        cmdPatterns, err := task.GetCheckCmdPatterns()
        if err != nil </span><span class="cov1" title="1">{
                return cmd, err
        }</span>
        <span class="cov1" title="2">cmd, err = task.getCmd("CHECK", cmdPatterns)
        return cmd, err</span>
}

func (task *Task) GetCheckCmdPatterns() (cmdPatterns []string, err error) <span class="cov3" title="8">{
        if !task.IsHavingCheckCmd() </span><span class="cov1" title="2">{
                return cmdPatterns, fmt.Errorf("cannot retrieve check cmd from any parent task of %s", task.GetName())
        }</span>
        <span class="cov3" title="6">if len(task.Check) &gt; 0 </span><span class="cov2" title="4">{
                return task.Check, nil
        }</span>
        <span class="cov1" title="2">for _, parentTaskName := range task.GetParentTaskNames() </span><span class="cov1" title="2">{
                parentTask := task.Project.Tasks[parentTaskName]
                cmdPatterns, err = parentTask.GetCheckCmdPatterns()
                if err != nil </span><span class="cov0" title="0">{
                        return cmdPatterns, err
                }</span>
        }
        <span class="cov1" title="2">return cmdPatterns, nil</span>
}

func (task *Task) getCmd(cmdType string, commandPatternArgs []string) (cmd *exec.Cmd, err error) <span class="cov3" title="9">{
        commandArgs := []string{}
        templateNamePrefix := fmt.Sprintf("%s[%s]", task.GetName(), strings.ToLower(cmdType))
        for _, pattern := range commandPatternArgs </span><span class="cov4" title="18">{
                arg, err := task.getParsedPattern(templateNamePrefix, pattern)
                if err != nil </span><span class="cov1" title="1">{
                        return cmd, err
                }</span>
                <span class="cov4" title="17">commandArgs = append(commandArgs, arg)</span>
        }
        <span class="cov3" title="8">name, args := commandArgs[0], commandArgs[1:]
        cmd = exec.Command(name, args...)
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{Setpgid: true}
        cmd.Dir = task.GetWorkPath()
        cmd.Env = os.Environ()
        // task env
        if err = task.setCmdEnv(cmd); err != nil </span><span class="cov1" title="1">{
                return cmd, err
        }</span>
        <span class="cov3" title="7">sessionId := task.Project.GetSessionId()
        // log stdout
        outPipe, _ := cmd.StdoutPipe()
        go task.readLogFromBuffer(sessionId, cmdType, "OUT", outPipe, task.Project.StdoutChan, task.Project.StdoutRecordChan)
        // log stderr
        errPipe, _ := cmd.StderrPipe()
        go task.readLogFromBuffer(sessionId, cmdType, "ERR", errPipe, task.Project.StderrChan, task.Project.StderrRecordChan)
        // combine stdout and stderr done
        return cmd, err</span>
}

func (task *Task) setCmdEnv(cmd *exec.Cmd) error <span class="cov3" title="8">{
        defaultEnvMap, err := task.getRuntimeEnvMap(false)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov3" title="7">for key, val := range defaultEnvMap </span><span class="cov4" title="23">{
                cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, val))
        }</span>
        <span class="cov3" title="7">return nil</span>
}

// getRuntimeEnvMap: is asPattern is true, this will return go template representing configs and inputs.
func (task *Task) getRuntimeEnvMap(asPattern bool) (taskEnvMap map[string]string, err error) <span class="cov7" title="152">{
        // envs.
        // envs should only be included if this is loaded as real environment, not as pattern.
        if asPattern </span><span class="cov7" title="144">{
                taskEnvMap = map[string]string{}
        }</span> else<span class="cov3" title="8"> {
                taskEnvMap, err = task.GetEnvs()
                if err != nil </span><span class="cov1" title="1">{
                        return taskEnvMap, err
                }</span>
        }
        // configs
        <span class="cov7" title="151">configKeys := task.GetConfigKeys()
        for _, configKey := range configKeys </span><span class="cov7" title="226">{
                configEnvKey := fmt.Sprintf("ZARUBA_CONFIG_%s", task.Project.Util.Str.ToUpperSnake(configKey))
                if asPattern </span><span class="cov7" title="225">{
                        taskEnvMap[configEnvKey] = fmt.Sprintf("{{ .GetConfig \"%s\" }}", configKey)
                        continue</span>
                }
                <span class="cov1" title="1">val, err := task.GetConfig(configKey)
                if err != nil </span><span class="cov0" title="0">{
                        return taskEnvMap, err
                }</span>
                <span class="cov1" title="1">taskEnvMap[configEnvKey] = val</span>
        }
        // inputs
        <span class="cov7" title="151">inputMap, _, _ := task.Project.GetInputs([]string{task.GetName()})
        for inputKey := range inputMap </span><span class="cov0" title="0">{
                inputEnvKey := fmt.Sprintf("ZARUBA_INPUT_%s", task.Project.Util.Str.ToUpperSnake(inputKey))
                if asPattern </span><span class="cov0" title="0">{
                        taskEnvMap[inputEnvKey] = fmt.Sprintf("{{ .GetInput \"%s\" }}", inputKey)
                        continue</span>
                }
                <span class="cov0" title="0">val, err := task.GetValue(inputKey)
                if err != nil </span><span class="cov0" title="0">{
                        return taskEnvMap, err
                }</span>
                <span class="cov0" title="0">taskEnvMap[inputEnvKey] = val</span>
        }
        // paths
        <span class="cov7" title="151">taskEnvMap["ZARUBA_TASK_DIR"] = task.GetDirPath()
        taskEnvMap["ZARUBA_PROJECT_DIR"] = task.Project.GetDirPath()
        taskEnvMap["ZARUBA_WORK_DIR"] = task.GetWorkPath()
        return taskEnvMap, err</span>
}

func (task *Task) readLogFromBuffer(sessionId, cmdType, logType string, pipe io.ReadCloser, logChan chan string, logRecordChan chan []string) <span class="cov4" title="14">{
        buf := bufio.NewScanner(pipe)
        isSaveLog := task.GetIsSaveLog()
        outputWgAdditionPerRow := 1
        if isSaveLog </span><span class="cov4" title="14">{
                outputWgAdditionPerRow = 2
        }</span>
        <span class="cov4" title="14">cmdIconType := task.getCmdIconType(cmdType)
        logPrefix := fmt.Sprintf("%s %s", cmdIconType, task.logPrefix)
        taskName := task.GetName()
        isFirstTime := true
        previousChan := make(chan bool)
        nextChan := make(chan bool)
        for buf.Scan() </span><span class="cov1" title="1">{
                task.Project.OutputWgMutex.Lock()
                task.Project.OutputWg.Add(outputWgAdditionPerRow)
                task.Project.OutputWgMutex.Unlock()
                content := buf.Text()
                // previous and next chan is necessary to make sure that logChan and logRecordChan get message in order
                if isFirstTime </span><span class="cov1" title="1">{
                        isFirstTime = false
                        go task.sendLog(cmdType, logType, logPrefix, sessionId, taskName, content, isSaveLog, previousChan, nextChan, logChan, logRecordChan)
                        previousChan &lt;- true
                        continue</span>
                }
                <span class="cov0" title="0">previousChan = nextChan
                nextChan = make(chan bool)
                go task.sendLog(cmdType, logType, logPrefix, sessionId, taskName, content, isSaveLog, previousChan, nextChan, logChan, logRecordChan)</span>
        }
}

func (task *Task) sendLog(cmdType, logType, logPrefix, sessionId, taskName, content string, saveLog bool, previousChan, nextChan chan bool, logChan chan string, logRecordChan chan []string) <span class="cov1" title="1">{
        d := task.Project.Decoration
        now := time.Now()
        decoratedContent := ""
        if task.Project.showLogTime </span><span class="cov0" title="0">{
                nowRoundStr := fmt.Sprintf("%-12s", now.Format("15:04:05.999"))
                decoratedContent = fmt.Sprintf("%s %s%s%s %s\n", logPrefix, d.Faint, nowRoundStr, d.Normal, content)
        }</span> else<span class="cov1" title="1"> {
                decoratedContent = fmt.Sprintf("%s %s\n", logPrefix, content)
        }</span>
        <span class="cov1" title="1">&lt;-previousChan
        logChan &lt;- decoratedContent
        if saveLog </span><span class="cov1" title="1">{
                nowStr := now.String()
                rowContent := []string{nowStr, logType, cmdType, taskName, content, sessionId}
                logRecordChan &lt;- rowContent
        }</span>
        <span class="cov0" title="0">nextChan &lt;- true</span>
}

func (task *Task) getUniqueElements(arr []string) (result []string) <span class="cov8" title="283">{
        result = []string{}
        seen := map[string]bool{}
        for _, element := range arr </span><span class="cov8" title="347">{
                if _, exist := seen[element]; exist </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="347">result = append(result, element)
                seen[element] = true</span>
        }
        <span class="cov8" title="283">return result</span>
}

func (task *Task) getCmdIconType(cmdType string) string <span class="cov4" title="14">{
        if cmdType == "CHECK" </span><span class="cov2" title="4">{
                return task.Project.Decoration.InspectIcon
        }</span>
        <span class="cov3" title="10">return task.Project.Decoration.RunIcon</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package dsl

import (
        "fmt"

        "github.com/state-alchemists/zaruba/yamlstyler"
        yaml "gopkg.in/yaml.v3"
)

type TaskConfigUtil struct {
        task *TaskUtil
}

func NewTaskConfigUtil(taskUtil *TaskUtil) *TaskConfigUtil <span class="cov10" title="121">{
        return &amp;TaskConfigUtil{
                task: taskUtil,
        }
}</span>

func (configUtil *TaskConfigUtil) Set(taskName string, configMap map[string]string, projectFile string) (err error) <span class="cov0" title="0">{
        if len(configMap) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">task, err := configUtil.task.getTaskByProjectFile(projectFile, taskName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">configRefName := task.GetFirstConfigRefName()
        if configRefName == "" </span><span class="cov0" title="0">{
                // update taskConfig
                return configUtil.set(task, configMap)
        }</span>
        // update configRef
        <span class="cov0" title="0">return configUtil.setConfigsRef(task.Project.ConfigRefMap[configRefName], configMap)</span>
}

func (configUtil *TaskConfigUtil) set(task *Task, configMap map[string]string) (err error) <span class="cov0" title="0">{
        taskName := task.GetName()
        yamlLocation := task.GetFileLocation()
        node, err := configUtil.task.file.ReadYamlNode(yamlLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">docNode := node.Content[0]
        for index := 0; index &lt; len(docNode.Content); index += 2 </span><span class="cov0" title="0">{
                keyNode := docNode.Content[index]
                valNode := docNode.Content[index+1]
                if keyNode.Value == "tasks" &amp;&amp; valNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                        for taskNameIndex := 0; taskNameIndex &lt; len(valNode.Content); taskNameIndex += 2 </span><span class="cov0" title="0">{
                                taskNameNode := valNode.Content[taskNameIndex]
                                taskNode := valNode.Content[taskNameIndex+1]
                                if taskNameNode.Value == taskName &amp;&amp; taskNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                                        for taskPropKeyIndex := 0; taskPropKeyIndex &lt; len(taskNode.Content); taskPropKeyIndex += 2 </span><span class="cov0" title="0">{
                                                taskPropKeyNode := taskNode.Content[taskPropKeyIndex]
                                                taskPropValNode := taskNode.Content[taskPropKeyIndex+1]
                                                if taskPropKeyNode.Value == "configs" &amp;&amp; taskPropValNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                                                        configUtil.updateConfigMapNode(taskPropValNode, configMap)
                                                        return configUtil.task.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})
                                                }</span>
                                        }
                                        // config not found
                                        <span class="cov0" title="0">taskNode.Style = yaml.LiteralStyle
                                        taskNode.Content = append(
                                                taskNode.Content,
                                                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "configs"},
                                                configUtil.createConfigMapNode(configMap),
                                        )
                                        return configUtil.task.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("cannot find task %s in %s", taskName, yamlLocation)</span>
}

func (configUtil *TaskConfigUtil) setConfigsRef(configRef *ConfigRef, configMap map[string]string) (err error) <span class="cov0" title="0">{
        configRefName := configRef.GetName()
        yamlLocation := configRef.GetFileLocation()
        node, err := configUtil.task.file.ReadYamlNode(yamlLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">docNode := node.Content[0]
        for index := 0; index &lt; len(docNode.Content); index += 2 </span><span class="cov0" title="0">{
                keyNode := docNode.Content[index]
                valNode := docNode.Content[index+1]
                if keyNode.Value == "configs" &amp;&amp; valNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                        for configRefNameIndex := 0; configRefNameIndex &lt; len(valNode.Content); configRefNameIndex += 2 </span><span class="cov0" title="0">{
                                configRefNameNode := valNode.Content[configRefNameIndex]
                                configRefNode := valNode.Content[configRefNameIndex+1]
                                if configRefNameNode.Value == configRefName &amp;&amp; configRefNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                                        configUtil.updateConfigMapNode(configRefNode, configMap)
                                        return configUtil.task.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("cannot find configRef %s in %s", configRefName, yamlLocation)</span>
}

func (configUtil *TaskConfigUtil) updateConfigMapNode(configMapNode *yaml.Node, configMap map[string]string) <span class="cov0" title="0">{
        configMapNode.Style = yaml.LiteralStyle
        for configKey, configVal := range configMap </span><span class="cov0" title="0">{
                configKeyFound := false
                for configKeyIndex := 0; configKeyIndex &lt; len(configMapNode.Content); configKeyIndex += 2 </span><span class="cov0" title="0">{
                        configKeyNode := configMapNode.Content[configKeyIndex]
                        configValNode := configMapNode.Content[configKeyIndex+1]
                        // "configs" and configKey found, update
                        if configKeyNode.Value == configKey </span><span class="cov0" title="0">{
                                configValNode.SetString(configVal)
                                configKeyFound = true
                                break</span>
                        }
                }
                // "configs" found, but configKey not found, create
                <span class="cov0" title="0">if !configKeyFound </span><span class="cov0" title="0">{
                        configMapNode.Content = append(configMapNode.Content, configUtil.createConfigNode(configKey, configVal)...)
                }</span>
        }
}

func (configUtil *TaskConfigUtil) createConfigMapNode(configMap map[string]string) *yaml.Node <span class="cov0" title="0">{
        newConfigNodes := []*yaml.Node{}
        for configKey, configVal := range configMap </span><span class="cov0" title="0">{
                newConfigNodes = append(
                        newConfigNodes,
                        configUtil.createConfigNode(configKey, configVal)...,
                )
        }</span>
        <span class="cov0" title="0">return &amp;yaml.Node{Kind: yaml.MappingNode, Content: newConfigNodes}</span>
}

func (configUtil *TaskConfigUtil) createConfigNode(configKey, configVal string) []*yaml.Node <span class="cov0" title="0">{
        return []*yaml.Node{
                {Kind: yaml.ScalarNode, Value: configKey},
                {Kind: yaml.ScalarNode, Value: configVal},
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package dsl

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/joho/godotenv"
        "github.com/state-alchemists/zaruba/dictutil"
        "github.com/state-alchemists/zaruba/pathutil"
        "github.com/state-alchemists/zaruba/yamlstyler"
        yaml "gopkg.in/yaml.v3"
)

type TaskEnvUtil struct {
        task *TaskUtil
}

func NewTaskEnvUtil(taskUtil *TaskUtil) *TaskEnvUtil <span class="cov10" title="121">{
        return &amp;TaskEnvUtil{
                task: taskUtil,
        }
}</span>

func (envUtil *TaskEnvUtil) Sync(taskName, projectFile string) (err error) <span class="cov0" title="0">{
        task, err := envUtil.task.getTaskByProjectFile(projectFile, taskName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !task.GetShouldSyncEnv() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">projectDir := filepath.Dir(task.Project.GetFileLocation())
        taskFileLocation := task.GetFileLocation()
        if !strings.HasPrefix(taskFileLocation, projectDir) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">syncEnvLocation := task.GetSyncEnvLocation()
        if syncEnvLocation == "" || syncEnvLocation == projectDir </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">locationEnvMap, err := pathutil.PathGetEnvByLocation(syncEnvLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">envRefName := task.GetFirstEnvRefName()
        if envRefName == "" </span><span class="cov0" title="0">{
                // update taskEnv
                newEnvMap := envUtil.getAdditionalEnvMap(task.Envs, locationEnvMap)
                if len(newEnvMap) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if err = envUtil.set(task, newEnvMap); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        // update envRef
        <span class="cov0" title="0">newEnvMap := envUtil.getAdditionalEnvMap(task.Project.EnvRefMap[envRefName].Map, locationEnvMap)
        if len(newEnvMap) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return envUtil.setEnvsRef(task.Project.EnvRefMap[envRefName], newEnvMap)</span>
}

func (envUtil *TaskEnvUtil) Set(taskName string, envMap map[string]string, projectFile string) (err error) <span class="cov0" title="0">{
        if len(envMap) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">task, err := envUtil.task.getTaskByProjectFile(projectFile, taskName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // adjust envFiles
        <span class="cov0" title="0">if err = envUtil.SyncEnvFiles(task, envMap, projectFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">envRefName := task.GetFirstEnvRefName()
        if envRefName == "" </span><span class="cov0" title="0">{
                // update taskEnv
                return envUtil.set(task, envMap)
        }</span>
        // update envRef
        <span class="cov0" title="0">return envUtil.setEnvsRef(task.Project.EnvRefMap[envRefName], envMap)</span>
}

func (envUtil *TaskEnvUtil) SyncEnvFiles(task *Task, envMap map[string]string, projectFile string) (err error) <span class="cov0" title="0">{
        envFileNames, err := task.Project.GetEnvFileNames()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, envFileName := range envFileNames </span><span class="cov0" title="0">{
                fileEnvMap, err := godotenv.Read(envFileName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for envKey := range envMap </span><span class="cov0" title="0">{
                        newEnvValue := envMap[envKey]
                        envObj, declared := task.GetEnvObject(envKey)
                        if !declared </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">envFrom := envObj.From
                        if envFrom == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if _, keyExist := fileEnvMap[envFrom]; !keyExist </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">envDefault := envObj.Default
                        fileEnvValue, exist := fileEnvMap[envFrom]
                        if exist &amp;&amp; fileEnvValue == envDefault </span><span class="cov0" title="0">{
                                fileEnvMap[envFrom] = newEnvValue
                        }</span>
                }
                <span class="cov0" title="0">godotenv.Write(fileEnvMap, envFileName)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (envUtil *TaskEnvUtil) set(task *Task, envMap map[string]string) (err error) <span class="cov0" title="0">{
        taskName := task.GetName()
        envPrefix := strings.ToUpper(task.Project.Util.Str.ToSnake(taskName))
        yamlLocation := task.GetFileLocation()
        node, err := envUtil.task.file.ReadYamlNode(yamlLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">docNode := node.Content[0]
        for index := 0; index &lt; len(docNode.Content); index += 2 </span><span class="cov0" title="0">{
                keyNode := docNode.Content[index]
                valNode := docNode.Content[index+1]
                if keyNode.Value == "tasks" &amp;&amp; valNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                        for taskNameIndex := 0; taskNameIndex &lt; len(valNode.Content); taskNameIndex += 2 </span><span class="cov0" title="0">{
                                taskNameNode := valNode.Content[taskNameIndex]
                                taskNode := valNode.Content[taskNameIndex+1]
                                if taskNameNode.Value == taskName &amp;&amp; taskNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                                        for taskPropKeyIndex := 0; taskPropKeyIndex &lt; len(taskNode.Content); taskPropKeyIndex += 2 </span><span class="cov0" title="0">{
                                                taskPropKeyNode := taskNode.Content[taskPropKeyIndex]
                                                taskPropValNode := taskNode.Content[taskPropKeyIndex+1]
                                                if taskPropKeyNode.Value == "envs" &amp;&amp; taskPropValNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                                                        envUtil.updateEnvMapNode(taskPropValNode, envMap, envPrefix)
                                                        return envUtil.task.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})
                                                }</span>
                                        }
                                        // env not found
                                        <span class="cov0" title="0">taskNode.Style = yaml.LiteralStyle
                                        taskNode.Content = append(
                                                taskNode.Content,
                                                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "envs"},
                                                envUtil.createEnvMapNode(envMap, envPrefix),
                                        )
                                        return envUtil.task.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("cannot find task %s in %s", taskName, yamlLocation)</span>
}

func (envUtil *TaskEnvUtil) setEnvsRef(envRef *EnvRef, envMap map[string]string) (err error) <span class="cov0" title="0">{
        util := NewDSLUtil()
        envRefName := envRef.GetName()
        envPrefix := strings.ToUpper(util.Str.ToSnake(envRefName))
        yamlLocation := envRef.GetFileLocation()
        node, err := envUtil.task.file.ReadYamlNode(yamlLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">docNode := node.Content[0]
        for index := 0; index &lt; len(docNode.Content); index += 2 </span><span class="cov0" title="0">{
                keyNode := docNode.Content[index]
                valNode := docNode.Content[index+1]
                if keyNode.Value == "envs" &amp;&amp; valNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                        for envRefNameIndex := 0; envRefNameIndex &lt; len(valNode.Content); envRefNameIndex += 2 </span><span class="cov0" title="0">{
                                envRefNameNode := valNode.Content[envRefNameIndex]
                                envRefNode := valNode.Content[envRefNameIndex+1]
                                if envRefNameNode.Value == envRefName &amp;&amp; envRefNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                                        envUtil.updateEnvMapNode(envRefNode, envMap, envPrefix)
                                        return envUtil.task.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("cannot find envRef %s in %s", envRefName, yamlLocation)</span>
}

func (envUtil *TaskEnvUtil) updateEnvMapNode(envMapNode *yaml.Node, envMap map[string]string, envPrefix string) <span class="cov0" title="0">{
        envMapNode.Style = yaml.LiteralStyle
        envKeys, _ := dictutil.DictGetSortedKeys(envMap)
        for _, envKey := range envKeys </span><span class="cov0" title="0">{
                envVal := envMap[envKey]
                envKeyFound := false
                for envKeyIndex := 0; envKeyIndex &lt; len(envMapNode.Content); envKeyIndex += 2 </span><span class="cov0" title="0">{
                        envKeyNode := envMapNode.Content[envKeyIndex]
                        envValNode := envMapNode.Content[envKeyIndex+1]
                        // "envs" and envKey found, update
                        if envKeyNode.Value == envKey </span><span class="cov0" title="0">{
                                envFromFound, envDefaultFound := false, false
                                envFrom := envUtil.getEnvFromName(envKey, envPrefix)
                                for envPropKeyIndex := 0; envPropKeyIndex &lt; len(envValNode.Content); envPropKeyIndex += 2 </span><span class="cov0" title="0">{
                                        envPropKeyNode := envValNode.Content[envPropKeyIndex]
                                        envPropValNode := envValNode.Content[envPropKeyIndex+1]
                                        switch envPropKeyNode.Value </span>{
                                        case "from":<span class="cov0" title="0">
                                                envPropValNode.SetString(envFrom)
                                                envFromFound = true</span>
                                        case "default":<span class="cov0" title="0">
                                                envPropValNode.SetString(envVal)
                                                envDefaultFound = true</span>
                                        }
                                }
                                <span class="cov0" title="0">if !envFromFound </span><span class="cov0" title="0">{
                                        envValNode.Content = append(envValNode.Content, envUtil.createEnvFromNode(envKey, envPrefix)...)
                                }</span>
                                <span class="cov0" title="0">if !envDefaultFound </span><span class="cov0" title="0">{
                                        envValNode.Content = append(envValNode.Content, envUtil.createEnvDefaultNode(envVal)...)
                                }</span>
                                <span class="cov0" title="0">envKeyFound = true
                                break</span>
                        }
                }
                // "envs" found, but envKey not found, create
                <span class="cov0" title="0">if !envKeyFound </span><span class="cov0" title="0">{
                        envMapNode.Content = append(envMapNode.Content, envUtil.createEnvNode(envKey, envVal, envPrefix)...)
                }</span>
        }
}

func (envUtil *TaskEnvUtil) createEnvMapNode(envMap map[string]string, envPrefix string) *yaml.Node <span class="cov0" title="0">{
        newEnvNodes := []*yaml.Node{}
        envKeys, _ := dictutil.DictGetSortedKeys(envMap)
        for _, envKey := range envKeys </span><span class="cov0" title="0">{
                envVal := envMap[envKey]
                newEnvNodes = append(
                        newEnvNodes,
                        envUtil.createEnvNode(envKey, envVal, envPrefix)...,
                )
        }</span>
        <span class="cov0" title="0">return &amp;yaml.Node{Kind: yaml.MappingNode, Content: newEnvNodes}</span>
}

func (envUtil *TaskEnvUtil) createEnvNode(envKey, envVal, envPrefix string) []*yaml.Node <span class="cov0" title="0">{
        return []*yaml.Node{
                {Kind: yaml.ScalarNode, Value: envKey},
                {
                        Kind: yaml.MappingNode,
                        Content: append(
                                envUtil.createEnvFromNode(envKey, envPrefix),
                                envUtil.createEnvDefaultNode(envVal)...,
                        ),
                },
        }
}</span>

func (envUtil *TaskEnvUtil) createEnvFromNode(envKey, envPrefix string) []*yaml.Node <span class="cov0" title="0">{
        envFrom := envUtil.getEnvFromName(envKey, envPrefix)
        return []*yaml.Node{
                {Kind: yaml.ScalarNode, Value: "from"},
                {Kind: yaml.ScalarNode, Value: envFrom},
        }
}</span>

func (envUtil *TaskEnvUtil) createEnvDefaultNode(envVal string) []*yaml.Node <span class="cov0" title="0">{
        return []*yaml.Node{
                {Kind: yaml.ScalarNode, Value: "default"},
                {Kind: yaml.ScalarNode, Value: envVal},
        }
}</span>

func (envUtil *TaskEnvUtil) getEnvFromName(envKey, envPrefix string) string <span class="cov0" title="0">{
        if !strings.HasPrefix(envKey, envPrefix) </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s_%s", envPrefix, envKey)
        }</span>
        <span class="cov0" title="0">return envKey</span>
}

func (envUtil *TaskEnvUtil) getAdditionalEnvMap(existingEnvMap map[string]*Env, locationEnvMap map[string]string) (additionalEnvMap map[string]string) <span class="cov0" title="0">{
        additionalEnvMap = map[string]string{}
        for envKey, envVal := range locationEnvMap </span><span class="cov0" title="0">{
                if _, exist := existingEnvMap[envKey]; exist </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">additionalEnvMap[envKey] = envVal</span>
        }
        <span class="cov0" title="0">return additionalEnvMap</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package dsl

import (
        "fmt"

        "github.com/state-alchemists/zaruba/fileutil"
        "github.com/state-alchemists/zaruba/jsonutil"
        "github.com/state-alchemists/zaruba/yamlstyler"
        yaml "gopkg.in/yaml.v3"
)

type TaskUtil struct {
        project *ProjectUtil
        file    *fileutil.FileUtil
        json    *jsonutil.JsonUtil
        Config  *TaskConfigUtil
        Env     *TaskEnvUtil
}

func NewTaskUtil(fileUtil *fileutil.FileUtil, jsonUtil *jsonutil.JsonUtil) *TaskUtil <span class="cov10" title="121">{
        taskUtil := &amp;TaskUtil{
                file: fileUtil,
                json: jsonUtil,
        }
        configUtil := NewTaskConfigUtil(taskUtil)
        taskUtil.Config = configUtil
        envUtil := NewTaskEnvUtil(taskUtil)
        taskUtil.Env = envUtil
        return taskUtil
}</span>

func (taskUtil *TaskUtil) getTaskByProjectFile(projectFile, taskName string) (task *Task, err error) <span class="cov0" title="0">{
        project, err := taskUtil.project.getProject(projectFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return taskUtil.getTaskByProject(project, taskName)</span>
}

func (taskUtil *TaskUtil) getTaskByProject(project *Project, taskName string) (task *Task, err error) <span class="cov0" title="0">{
        task, taskExist := project.Tasks[taskName]
        if !taskExist </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task %s does not exist", taskName)
        }</span>
        <span class="cov0" title="0">return task, nil</span>
}

func (taskUtil *TaskUtil) GetIcon(taskName, projectFile string) (icon string, err error) <span class="cov0" title="0">{
        project, err := taskUtil.project.getProject(projectFile)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">task, taskExist := project.Tasks[taskName]
        if !taskExist </span><span class="cov0" title="0">{
                return "", fmt.Errorf("task %s does not exist", taskName)
        }</span>
        <span class="cov0" title="0">return task.GetIcon(), nil</span>
}

func (taskUtil *TaskUtil) IsExist(taskName, projectFile string) (exist bool, err error) <span class="cov0" title="0">{
        project, err := taskUtil.project.getProject(projectFile)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">_, exist = project.Tasks[taskName]
        return exist, nil</span>
}

func (taskUtil *TaskUtil) AddDependencies(taskName string, dependencyTaskNames []string, projectFile string) (err error) <span class="cov0" title="0">{
        if len(dependencyTaskNames) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">task, err := taskUtil.getTaskByProjectFile(projectFile, taskName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, dependencyTaskName := range dependencyTaskNames </span><span class="cov0" title="0">{
                if _, dependencyExist := task.Project.Tasks[dependencyTaskName]; !dependencyExist </span><span class="cov0" title="0">{
                        return fmt.Errorf("dependency task %s does not exist", dependencyTaskName)
                }</span>
        }
        <span class="cov0" title="0">yamlLocation := task.GetFileLocation()
        node, err := taskUtil.file.ReadYamlNode(yamlLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // declare new dependencies
        <span class="cov0" title="0">newDependencyVals := []*yaml.Node{}
        for _, dependencyTaskName := range dependencyTaskNames </span><span class="cov0" title="0">{
                newDependencyVals = append(newDependencyVals, &amp;yaml.Node{Kind: yaml.ScalarNode, Value: dependencyTaskName})
        }</span>
        <span class="cov0" title="0">docNode := node.Content[0]
        for index := 0; index &lt; len(docNode.Content); index += 2 </span><span class="cov0" title="0">{
                keyNode := docNode.Content[index]
                valNode := docNode.Content[index+1]
                if keyNode.Value == "tasks" &amp;&amp; valNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                        for taskNameIndex := 0; taskNameIndex &lt; len(valNode.Content); taskNameIndex += 2 </span><span class="cov0" title="0">{
                                taskNameNode := valNode.Content[taskNameIndex]
                                taskNode := valNode.Content[taskNameIndex+1]
                                if taskNameNode.Value == taskName &amp;&amp; taskNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                                        for taskPropKeyIndex := 0; taskPropKeyIndex &lt; len(taskNode.Content); taskPropKeyIndex += 2 </span><span class="cov0" title="0">{
                                                taskPropKeyNode := taskNode.Content[taskPropKeyIndex]
                                                taskPropValNode := taskNode.Content[taskPropKeyIndex+1]
                                                if taskPropKeyNode.Value == "dependencies" &amp;&amp; taskPropValNode.ShortTag() == "!!seq" </span><span class="cov0" title="0">{
                                                        taskPropValNode.Style = yaml.LiteralStyle
                                                        taskPropValNode.Content = append(taskPropValNode.Content, newDependencyVals...)
                                                        return taskUtil.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})
                                                }</span>
                                        }
                                        <span class="cov0" title="0">taskNode.Style = yaml.LiteralStyle
                                        taskNode.Content = append(
                                                taskNode.Content,
                                                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "dependencies"},
                                                &amp;yaml.Node{Kind: yaml.SequenceNode, Content: newDependencyVals},
                                        )
                                        return taskUtil.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("cannot find task %s in %s", taskName, yamlLocation)</span>
}

func (taskUtil *TaskUtil) AddParents(taskName string, parentTaskNames []string, projectFile string) (err error) <span class="cov0" title="0">{
        if len(parentTaskNames) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">task, err := taskUtil.getTaskByProjectFile(projectFile, taskName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, parentTaskName := range parentTaskNames </span><span class="cov0" title="0">{
                if _, parentExist := task.Project.Tasks[parentTaskName]; !parentExist </span><span class="cov0" title="0">{
                        return fmt.Errorf("parent task %s does not exist", parentTaskName)
                }</span>
        }
        <span class="cov0" title="0">yamlLocation := task.GetFileLocation()
        node, err := taskUtil.file.ReadYamlNode(yamlLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // declare new parents
        <span class="cov0" title="0">newParentVals := []*yaml.Node{}
        for _, parentTaskName := range parentTaskNames </span><span class="cov0" title="0">{
                newParentVals = append(newParentVals, &amp;yaml.Node{Kind: yaml.ScalarNode, Value: parentTaskName})
        }</span>
        <span class="cov0" title="0">docNode := node.Content[0]
        for index := 0; index &lt; len(docNode.Content); index += 2 </span><span class="cov0" title="0">{
                keyNode := docNode.Content[index]
                valNode := docNode.Content[index+1]
                if keyNode.Value == "tasks" &amp;&amp; valNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                        // look for "taskName"
                        for taskNameIndex := 0; taskNameIndex &lt; len(valNode.Content); taskNameIndex += 2 </span><span class="cov0" title="0">{
                                taskNameNode := valNode.Content[taskNameIndex]
                                taskNode := valNode.Content[taskNameIndex+1]
                                if taskNameNode.Value == taskName &amp;&amp; taskNode.ShortTag() == "!!map" </span><span class="cov0" title="0">{
                                        // look for "extend", if it is found, add to newParentVals, remove "extend"
                                        extendFound := false
                                        for taskPropKeyIndex := 0; taskPropKeyIndex &lt; len(taskNode.Content); taskPropKeyIndex += 2 </span><span class="cov0" title="0">{
                                                taskPropKeyNode := taskNode.Content[taskPropKeyIndex]
                                                taskPropValNode := taskNode.Content[taskPropKeyIndex+1]
                                                if taskPropKeyNode.Value == "extend" </span><span class="cov0" title="0">{
                                                        extendFound = true
                                                        newParentVals = append(newParentVals, taskPropValNode)
                                                        newTaskNodeContent := taskNode.Content[0:taskPropKeyIndex]
                                                        if taskPropKeyIndex+2 &lt; len(taskNode.Content) </span><span class="cov0" title="0">{
                                                                newTaskNodeContent = append(newTaskNodeContent, taskNode.Content[taskPropKeyIndex+2:]...)
                                                        }</span>
                                                        <span class="cov0" title="0">taskNode.Content = newTaskNodeContent
                                                        break</span>
                                                }
                                        }
                                        // look for "extends"
                                        <span class="cov0" title="0">for taskPropKeyIndex := 0; taskPropKeyIndex &lt; len(taskNode.Content); taskPropKeyIndex += 2 </span><span class="cov0" title="0">{
                                                taskPropKeyNode := taskNode.Content[taskPropKeyIndex]
                                                taskPropValNode := taskNode.Content[taskPropKeyIndex+1]
                                                // "extends" found, add our new parents to "extends"
                                                if taskPropKeyNode.Value == "extends" &amp;&amp; taskPropValNode.ShortTag() == "!!seq" </span><span class="cov0" title="0">{
                                                        taskPropValNode.Style = yaml.LiteralStyle
                                                        taskPropValNode.Content = append(taskPropValNode.Content, newParentVals...)
                                                        return taskUtil.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})
                                                }</span>
                                        }
                                        // "extends" and "extend" not found and we only have one new parent, then we set "extend" to new parent
                                        <span class="cov0" title="0">if !extendFound &amp;&amp; len(newParentVals) == 1 </span><span class="cov0" title="0">{
                                                taskNode.Style = yaml.LiteralStyle
                                                taskNode.Content = append(
                                                        taskNode.Content,
                                                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "extend"},
                                                        newParentVals[0],
                                                )
                                                return taskUtil.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})
                                        }</span>
                                        // "extends" not found and we have multiple parents, then create "extends"
                                        <span class="cov0" title="0">taskNode.Style = yaml.LiteralStyle
                                        taskNode.Content = append(
                                                taskNode.Content,
                                                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "extends"},
                                                &amp;yaml.Node{Kind: yaml.SequenceNode, Content: newParentVals},
                                        )
                                        return taskUtil.file.WriteYamlNode(yamlLocation, node, 0555, []yamlstyler.YamlStyler{yamlstyler.TwoSpaces, yamlstyler.FixEmoji, yamlstyler.AddLineBreak})</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("cannot find task %s in %s", taskName, yamlLocation)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package dsl

import (
        "bytes"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "text/template"

        "github.com/state-alchemists/zaruba/output"
)

type Tpl struct {
        task                *Task
        ZarubaHome          string
        ZarubaBin           string
        Name                string
        ProjectName         string
        UUID                string
        GeneratedRandomName string
        WorkDir             string
        TaskDir             string
        ProjectDir          string
        FileLocation        string
        Decoration          *output.Decoration
        Util                *DSLUtil
}

func NewTpl(task *Task) (td *Tpl) <span class="cov10" title="133">{
        zarubaHome := os.Getenv("ZARUBA_HOME")
        if zarubaHome == "" </span><span class="cov0" title="0">{
                executable, _ := os.Executable()
                zarubaHome = filepath.Dir(executable)
        }</span>
        <span class="cov10" title="133">nextTask := *task
        nextTask.currentRecursiveLevel++
        return &amp;Tpl{
                task:                &amp;nextTask,
                ZarubaHome:          zarubaHome,
                ZarubaBin:           filepath.Join(zarubaHome, "zaruba"),
                Name:                task.GetName(),
                ProjectName:         task.Project.GetName(),
                UUID:                task.GetUUID(),
                GeneratedRandomName: task.GetGeneratedRandomName(),
                WorkDir:             task.GetWorkPath(),
                ProjectDir:          task.Project.GetDirPath(),
                TaskDir:             task.GetDirPath(),
                FileLocation:        task.GetFileLocation(),
                Decoration:          task.Project.Decoration,
                Util:                task.Project.Util,
        }</span>
}

func (tpl *Tpl) GetWorkPath(path string) (absPath string) <span class="cov4" title="6">{
        return tpl.getAbsPath(tpl.WorkDir, path)
}</span>

func (tpl *Tpl) GetTaskPath(path string) (absPath string) <span class="cov2" title="2">{
        return tpl.getAbsPath(tpl.TaskDir, path)
}</span>

func (tpl *Tpl) GetProjectPath(path string) (absPath string) <span class="cov0" title="0">{
        return tpl.getAbsPath(tpl.ProjectDir, path)
}</span>

func (tpl *Tpl) GetConfig(key string) (val string, err error) <span class="cov9" title="104">{
        return tpl.task.GetConfig(key)
}</span>

func (tpl *Tpl) GetConfigs(keyPattern string) (parsedConfig map[string]string, err error) <span class="cov0" title="0">{
        return tpl.task.GetConfigs(keyPattern)
}</span>

func (tpl *Tpl) GetPorts() []int <span class="cov0" title="0">{
        ports := []int{}
        portStr, _ := tpl.GetConfig("ports")
        lines := strings.Split(portStr, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.Trim(line, " \"'")
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">portParts := strings.Split(line, ":")
                if len(portParts) &gt; 1 </span><span class="cov0" title="0">{
                        port, _ := strconv.Atoi(portParts[1])
                        ports = append(ports, port)
                        continue</span>
                }
                <span class="cov0" title="0">port, _ := strconv.Atoi(portParts[0])
                ports = append(ports, port)</span>
        }
        <span class="cov0" title="0">return ports</span>
}

func (tpl *Tpl) GetSubValueKeys(parentKeys ...string) (subKeys []string) <span class="cov1" title="1">{
        keys := tpl.task.GetValueKeys()
        seen := map[string]bool{}
        parentKey := strings.Join(parentKeys, "::")
        prefixLength := len(parentKey) + len("::")
        subKeys = []string{}
        for _, key := range keys </span><span class="cov2" title="2">{
                if !strings.HasPrefix(key, parentKey+"::") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov2" title="2">childKey := key[prefixLength:]
                if childKey == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov2" title="2">childKeyParts := strings.SplitN(childKey, "::", 2)
                subkey := childKeyParts[0]
                seen[subkey] = true</span>
        }
        <span class="cov1" title="1">for key := range seen </span><span class="cov2" title="2">{
                subKeys = append(subKeys, key)
        }</span>
        <span class="cov1" title="1">return subKeys</span>
}

func (tpl *Tpl) GetValue(keys ...string) (val string, err error) <span class="cov2" title="2">{
        return tpl.task.GetValue(keys...)
}</span>

func (tpl *Tpl) GetEnv(key string) (val string, err error) <span class="cov2" title="2">{
        return tpl.task.GetEnv(key)
}</span>

func (tpl *Tpl) GetEnvs() (parsedEnv map[string]string, err error) <span class="cov1" title="1">{
        return tpl.task.GetEnvs()
}</span>

func (tpl *Tpl) ReplaceAll(s, old, new string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(s, old, new)
}</span>

func (tpl *Tpl) GetDockerImageName() string <span class="cov0" title="0">{
        dockerImagePrefix := ""
        useImagePrefix, _ := tpl.GetConfig("useImagePrefix")
        if tpl.Util.Bool.IsTrue(useImagePrefix) </span><span class="cov0" title="0">{
                dockerImagePrefix, _ = tpl.GetConfig("imagePrefix")
        }</span>
        <span class="cov0" title="0">dockerImageName, _ := tpl.GetConfig("imageName")
        if dockerImageName == "" </span><span class="cov0" title="0">{
                defaultServiceName, _ := tpl.Util.Path.GetDefaultAppName(tpl.TaskDir)
                dockerImageName = tpl.task.Project.Util.Str.ToKebab(defaultServiceName)
        }</span>
        <span class="cov0" title="0">if dockerImagePrefix == "" </span><span class="cov0" title="0">{
                return dockerImageName
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s/%s", dockerImagePrefix, dockerImageName)</span>
}

func (tpl *Tpl) ParseFile(filePath string) (parsedStr string, err error) <span class="cov3" title="4">{
        absFilePath := tpl.GetWorkPath(filePath)
        pattern, err := tpl.Util.File.ReadText(absFilePath)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov3" title="3">templateName := fmt.Sprintf("File: %s", absFilePath)
        tmpl, err := template.New(templateName).Option("missingkey=zero").Parse(pattern)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov2" title="2">var b bytes.Buffer
        if err = tmpl.Execute(&amp;b, tpl); err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov1" title="1">return b.String(), nil</span>
}

func (tpl *Tpl) Template(content string) (escapedStr string) <span class="cov0" title="0">{
        return fmt.Sprintf("{{ %s }}", content)
}</span>

func (tpl *Tpl) getAbsPath(parentPath, path string) (absPath string) <span class="cov4" title="8">{
        if filepath.IsAbs(path) </span><span class="cov2" title="2">{
                return path
        }</span>
        <span class="cov4" title="6">absParentPath, _ := filepath.Abs(parentPath)
        return filepath.Join(absParentPath, path)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package dsl

import (
        "fmt"
        "regexp"
)

// Variable configuration
type Variable struct {
        DefaultValue string   `yaml:"default,omitempty"`
        Description  string   `yaml:"description,omitempty"`
        Secret       bool     `yaml:"secret,omitempty"`
        Validation   string   `yaml:"validation,omitempty"`
        Options      []string `yaml:"options,omitempty"`
        Prompt       string   `yaml:"prompt,omitempty"`
        AllowCustom  string   `yaml:"allowCustom,omitempty"`
        Project      *Project `yaml:"_project,omitempty"`
        fileLocation string
        name         string
}

// GetName get name of input
func (variable *Variable) GetName() (name string) <span class="cov1" title="1">{
        return variable.name
}</span>

// Validate validate a value
func (input *Variable) Validate(value string) (err error) <span class="cov10" title="18">{
        if input.Validation == "" </span><span class="cov8" title="11">{
                return nil
        }</span>
        <span class="cov7" title="7">valid, err := regexp.Match(input.Validation, []byte(value))
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov6" title="6">if !valid </span><span class="cov4" title="3">{
                return fmt.Errorf("value of input variable '%s' does not match '%s': %s", input.name, input.Validation, value)
        }</span>
        <span class="cov4" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package runner

import (
        "fmt"
        "io"
        "os"
        "os/exec"
        "os/signal"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/state-alchemists/zaruba/dsl"
        "github.com/state-alchemists/zaruba/output"
)

// Runner is used to run tasks
type Runner struct {
        taskNames              []string
        project                *dsl.Project
        taskStatus             map[string]*TaskStatus
        taskStatusMutex        *sync.RWMutex
        cmdInfo                map[string]*CmdInfo
        cmdInfoMutex           *sync.RWMutex
        killed                 bool
        killedMutex            *sync.RWMutex
        done                   bool
        doneMutex              *sync.RWMutex
        statusTimeInterval     time.Duration
        statusLineInterval     int
        startTimeMutex         *sync.RWMutex
        startTime              time.Time
        spaces                 string
        surpressWaitError      bool
        surpressWaitErrorMutex *sync.RWMutex
        logger                 output.Logger
        recordLogger           output.RecordLogger
        decoration             *output.Decoration
        autoTerminate          bool
        autoTerminateDelay     time.Duration
}

// NewRunner create new runner
func NewRunner(logger output.Logger, recordLogger output.RecordLogger, project *dsl.Project, taskNames []string, statusTImeIntervalStr string, statusLineInterval int, autoTerminate bool, autoTerminateDelayStr string) (runner *Runner, err error) <span class="cov4" title="11">{
        if !project.IsInitialized </span><span class="cov1" title="1">{
                return &amp;Runner{}, fmt.Errorf("cannot create runner because project was not initialized")
        }</span>
        <span class="cov4" title="10">if err = project.ValidateByTaskNames(taskNames); err != nil </span><span class="cov1" title="1">{
                return &amp;Runner{}, err
        }</span>
        <span class="cov4" title="9">if project.GetAutoTerminate(taskNames) </span><span class="cov2" title="2">{
                autoTerminate = true
        }</span>
        <span class="cov4" title="9">statusTImeInterval, err := time.ParseDuration(statusTImeIntervalStr)
        if err != nil </span><span class="cov1" title="1">{
                return &amp;Runner{}, fmt.Errorf("cannot parse statusInterval '%s': %s", statusTImeIntervalStr, err)
        }</span>
        <span class="cov4" title="8">autoTerminateDelayInterval, err := time.ParseDuration(autoTerminateDelayStr)
        if err != nil </span><span class="cov1" title="1">{
                return &amp;Runner{}, fmt.Errorf("cannot parse autoTerminateDelay '%s': %s", autoTerminateDelayStr, err)
        }</span>
        <span class="cov3" title="7">return &amp;Runner{
                taskNames:              taskNames,
                project:                project,
                taskStatus:             map[string]*TaskStatus{},
                taskStatusMutex:        &amp;sync.RWMutex{},
                cmdInfo:                map[string]*CmdInfo{},
                cmdInfoMutex:           &amp;sync.RWMutex{},
                killed:                 false,
                killedMutex:            &amp;sync.RWMutex{},
                done:                   false,
                doneMutex:              &amp;sync.RWMutex{},
                statusTimeInterval:     statusTImeInterval,
                statusLineInterval:     statusLineInterval,
                startTimeMutex:         &amp;sync.RWMutex{},
                spaces:                 fmt.Sprintf("%s %s", project.Decoration.EmptyIcon, project.Decoration.EmptyIcon),
                surpressWaitError:      false,
                surpressWaitErrorMutex: &amp;sync.RWMutex{},
                logger:                 logger,
                recordLogger:           recordLogger,
                decoration:             project.Decoration,
                autoTerminate:          autoTerminate,
                autoTerminateDelay:     autoTerminateDelayInterval,
        }, nil</span>
}

// Run Tasks
func (r *Runner) Run() (err error) <span class="cov3" title="7">{
        r.startTime = time.Now()
        r.showStatus()
        go r.logStderr()
        go r.logStdout()
        go r.logStderrRow()
        go r.logStdoutRow()
        ch := make(chan error)
        go r.handleTerminationSignal(ch)
        go r.run(ch)
        go r.waitLongRunningCmd(ch)
        go r.showStatusByInterval()
        err = &lt;-ch
        r.waitOutputWg(50*time.Millisecond, 2)
        if err == nil &amp;&amp; r.getKilledSignal() </span><span class="cov0" title="0">{
                r.showStatus()
                return fmt.Errorf("Terminated")
        }</span>
        <span class="cov3" title="7">if !r.getKilledSignal() </span><span class="cov3" title="6">{
                r.waitOutputWg(50*time.Millisecond, 4)
                r.Terminate()
        }</span>
        <span class="cov3" title="7">r.showStatus()
        return err</span>
}

func (r *Runner) waitOutputWg(sleepDuration time.Duration, maxWaitAttempt int) <span class="cov4" title="13">{
        for waitAttempt := 0; waitAttempt &lt; maxWaitAttempt; waitAttempt++ </span><span class="cov6" title="38">{
                r.sleep(sleepDuration)
                r.project.OutputWg.Wait()
        }</span>
}

// Terminate all processes
func (r *Runner) Terminate() <span class="cov3" title="7">{
        r.logger.DPrintfError("Terminating\n")
        r.setKilledSignal()
        // kill unfinished commands
        r.cmdInfoMutex.Lock()
        defer r.cmdInfoMutex.Unlock()
        killedCh := map[string]chan error{}
        for label, cmdInfo := range r.cmdInfo </span><span class="cov3" title="5">{
                killedCh[label] = make(chan error)
                cmd := cmdInfo.Cmd
                r.logger.DPrintfKill("Kill %s (PID=%d)\n", label, cmd.Process.Pid)
                go r.killByPid(-cmd.Process.Pid, killedCh[label])
        }</span>
        <span class="cov3" title="7">for label := range r.cmdInfo </span><span class="cov3" title="5">{
                if err := &lt;-killedCh[label]; err != nil </span><span class="cov0" title="0">{
                        r.logger.Println(r.spaces, err)
                }</span>
                <span class="cov3" title="5">delete(r.cmdInfo, label)</span>
        }
}

func (r *Runner) logStdout() <span class="cov3" title="7">{
        lineCounter := 0
        for </span><span class="cov6" title="39">{
                content := &lt;-r.project.StdoutChan
                r.logger.DPrintf(content)
                r.project.OutputWgMutex.Lock()
                r.project.OutputWg.Done()
                r.project.OutputWgMutex.Unlock()
                if r.statusLineInterval &lt; 1 </span><span class="cov6" title="32">{
                        continue</span>
                }
                <span class="cov0" title="0">lineCounter++
                if lineCounter &gt;= r.statusLineInterval </span><span class="cov0" title="0">{
                        lineCounter = 0
                        r.showStatus()
                }</span>
        }
}

func (r *Runner) logStderr() <span class="cov3" title="7">{
        for </span><span class="cov3" title="7">{
                content := &lt;-r.project.StderrChan
                r.logger.DPrintfError(content)
                r.project.ProcessOutputWg()
        }</span>
}

func (r *Runner) logStdoutRow() <span class="cov3" title="7">{
        for </span><span class="cov6" title="39">{
                content := &lt;-r.project.StdoutRecordChan
                r.recordLogger.Log(content...)
                r.project.ProcessOutputWg()
        }</span>
}

func (r *Runner) logStderrRow() <span class="cov3" title="7">{
        for </span><span class="cov3" title="7">{
                content := &lt;-r.project.StderrRecordChan
                r.recordLogger.Log(content...)
                r.project.ProcessOutputWg()
        }</span>
}

func (r *Runner) showStatusByInterval() <span class="cov3" title="7">{
        for </span><span class="cov3" title="7">{
                r.sleep(r.statusTimeInterval)
                if r.getKilledSignal() </span><span class="cov2" title="2">{
                        return
                }</span>
                <span class="cov0" title="0">r.showStatus()</span>
        }
}

func (r *Runner) handleTerminationSignal(ch chan error) <span class="cov3" title="7">{
        signalChannel := make(chan os.Signal, 2)
        signal.Notify(signalChannel, os.Interrupt, syscall.SIGTERM)
        sig := &lt;-signalChannel
        errorMsg := ""
        switch sig </span>{
        case os.Interrupt:<span class="cov0" title="0">
                errorMsg = "Receiving SIGINT"</span>
        case syscall.SIGTERM:<span class="cov0" title="0">
                errorMsg = "Receiving SIGTERM"</span>
        default:<span class="cov0" title="0">
                errorMsg = "Receiving termination signal"</span>
        }
        <span class="cov0" title="0">r.logger.Println()
        r.logger.DPrintfError("%s\n", errorMsg)
        ch &lt;- fmt.Errorf(errorMsg)</span>
}

func (r *Runner) setSurpressWaitErrorSignal() <span class="cov3" title="5">{
        r.surpressWaitErrorMutex.Lock()
        r.surpressWaitError = true
        r.surpressWaitErrorMutex.Unlock()
}</span>

func (r *Runner) getSurpressWaitErrorSignal() (isSurpressWaitError bool) <span class="cov3" title="7">{
        r.surpressWaitErrorMutex.RLock()
        isSurpressWaitError = r.surpressWaitError
        r.surpressWaitErrorMutex.RUnlock()
        return isSurpressWaitError
}</span>

func (r *Runner) setDoneSignal() <span class="cov3" title="4">{
        r.doneMutex.Lock()
        r.done = true
        r.doneMutex.Unlock()
}</span>

func (r *Runner) getDoneSignal() (isDone bool) <span class="cov4" title="11">{
        r.doneMutex.RLock()
        isDone = r.done
        r.doneMutex.RUnlock()
        return isDone
}</span>

func (r *Runner) setKilledSignal() <span class="cov3" title="7">{
        r.killedMutex.Lock()
        r.killed = true
        r.killedMutex.Unlock()
}</span>

func (r *Runner) getKilledSignal() (isKilled bool) <span class="cov9" title="399">{
        r.killedMutex.RLock()
        isKilled = r.killed
        r.killedMutex.RUnlock()
        return isKilled
}</span>

func (r *Runner) run(ch chan error) <span class="cov3" title="7">{
        if err := r.runTaskByNames(r.taskNames); err != nil </span><span class="cov2" title="3">{
                ch &lt;- err
                return
        }</span>
        <span class="cov3" title="4">r.setDoneSignal()
        r.showStatus()
        d := r.decoration
        r.logger.DPrintfSuccess("%s\n", strings.Repeat(d.SuccessIcon, 11))
        r.logger.DPrintfSuccess("%s%sJob Complete!!! %s%s\n", d.Bold, d.Green, strings.Repeat(d.SuccessIcon, 3), d.Normal)
        if r.autoTerminate </span><span class="cov2" title="2">{
                r.sleep(r.autoTerminateDelay)
                ch &lt;- nil
                return
        }</span>
        // wait until no cmd left
        <span class="cov2" title="2">for </span><span class="cov6" title="31">{
                r.sleep(100 * time.Millisecond)
                if r.getKilledSignal() </span><span class="cov1" title="1">{
                        ch &lt;- fmt.Errorf("Terminated")
                        return
                }</span>
                <span class="cov6" title="30">processExist := false
                r.cmdInfoMutex.RLock()
                for range r.cmdInfo </span><span class="cov5" title="29">{
                        processExist = true
                        break</span>
                }
                <span class="cov6" title="30">r.cmdInfoMutex.RUnlock()
                if !processExist </span><span class="cov1" title="1">{
                        ch &lt;- nil
                        return
                }</span>
        }
}

func (r *Runner) runTaskByNames(taskNames []string) (err error) <span class="cov6" title="46">{
        tasks := []*dsl.Task{}
        for _, taskName := range taskNames </span><span class="cov7" title="92">{
                task := r.project.Tasks[taskName]
                tasks = append(tasks, task)
        }</span>
        <span class="cov6" title="46">ch := make(chan error)
        for _, task := range tasks </span><span class="cov7" title="92">{
                go r.runTask(task, ch)
        }</span>
        <span class="cov6" title="46">for index := 0; index &lt; len(tasks); index++ </span><span class="cov7" title="92">{
                err = &lt;-ch
                if err != nil </span><span class="cov3" title="4">{
                        return err
                }</span>
        }
        <span class="cov6" title="42">return err</span>
}

func (r *Runner) runTask(task *dsl.Task, ch chan error) <span class="cov7" title="92">{
        if !r.registerTask(task.GetName()) </span><span class="cov6" title="53">{
                ch &lt;- r.waitTaskFinished(task.GetName())
                return
        }</span>
        <span class="cov6" title="39">if err := r.runTaskByNames(task.GetDependencies()); err != nil </span><span class="cov1" title="1">{
                ch &lt;- err
                return
        }</span>
        <span class="cov6" title="38">if !task.IsHavingStartCmd() </span><span class="cov3" title="6">{
                // wrapper task
                r.logger.DPrintfSuccess("Reach %s %s%s wrapper%s\n", task.GetDecoratedIcon(), task.GetColor(), task.GetName(), r.decoration.Normal)
                r.markTaskFinished(task.GetName(), nil)
                ch &lt;- nil
                return
        }</span>
        <span class="cov6" title="32">if !task.IsHavingCheckCmd() </span><span class="cov5" title="26">{
                // simple task
                err := r.runSimpleTask(task)
                r.markTaskFinished(task.GetName(), err)
                ch &lt;- err
                return
        }</span>
        // long running task
        <span class="cov3" title="6">err := r.runLongRunningTask(task)
        r.markTaskFinished(task.GetName(), err)
        ch &lt;- err</span>
}

func (r *Runner) runSimpleTask(task *dsl.Task) (err error) <span class="cov5" title="26">{
        maxStartRetry := task.GetMaxStartRetry()
        startRetryDelayDuration := task.GetStartRetryDelayDuration()
        startCmdLabel := fmt.Sprintf("%s %s%s runner%s", task.GetDecoratedIcon(), task.GetColor(), task.GetName(), r.decoration.Normal)
        err = r.waitSimpleCmd(startCmdLabel, task, task.GetStartCmd, maxStartRetry, startRetryDelayDuration)
        r.unregisterCmd(startCmdLabel)
        return err
}</span>

func (r *Runner) runLongRunningTask(task *dsl.Task) (err error) <span class="cov3" title="6">{
        if err = r.startLongRunningTask(task); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="6">err = r.checkLongRunningTask(task)
        return err</span>
}

func (r *Runner) startLongRunningTask(task *dsl.Task) (err error) <span class="cov3" title="6">{
        maxRetry := task.GetMaxStartRetry()
        retryDelayDuration := task.GetStartRetryDelayDuration()
        cmdLabel := fmt.Sprintf("%s %s%s starter%s", task.GetDecoratedIcon(), task.GetColor(), task.GetName(), r.decoration.Normal)
        cmdMaker := task.GetStartCmd
        cmd, startStdinPipe, err := r.createCmdAndStdinPipe(cmdMaker)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="6">r.logger.DPrintfStarted("Running %s %s on %s\n", cmdLabel, r.getRetryAttemptCaption(1, maxRetry), cmd.Dir)
        if err = cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="6">r.registerCmd(cmdLabel, task, cmdMaker, cmd, startStdinPipe, 1, maxRetry, retryDelayDuration, true)
        return nil</span>
}

func (r *Runner) checkLongRunningTask(task *dsl.Task) (err error) <span class="cov3" title="6">{
        maxCheckRetry := task.GetMaxCheckRetry()
        checkRetryDelayDuration := task.GetCheckRetryDelayDuration()
        checkCmdLabel := fmt.Sprintf("%s %s%s readiness checker%s", task.GetDecoratedIcon(), task.GetColor(), task.GetName(), r.decoration.Normal)
        err = r.waitSimpleCmd(checkCmdLabel, task, task.GetCheckCmd, maxCheckRetry, checkRetryDelayDuration)
        r.unregisterCmd(checkCmdLabel)
        return err
}</span>

func (r *Runner) waitSimpleCmd(cmdLabel string, task *dsl.Task, cmdMaker func() (*exec.Cmd, error), maxRetry int, retryDelayDuration time.Duration) (err error) <span class="cov6" title="32">{
        timeoutDuration := task.GetTimeoutDuration()
        executed := false
        ch := make(chan error)
        // run task
        go func() </span><span class="cov6" title="32">{
                var cmdErr error
                var cmd *exec.Cmd
                var stdinPipe io.WriteCloser
                for attempt := 1; r.shouldRetry(attempt, maxRetry); attempt++ </span><span class="cov6" title="34">{
                        cmd, stdinPipe, cmdErr = r.createCmdAndStdinPipe(cmdMaker)
                        if cmdErr != nil </span><span class="cov0" title="0">{
                                ch &lt;- cmdErr
                                return
                        }</span>
                        <span class="cov6" title="34">r.logger.DPrintfStarted("Running %s %s on %s\n", cmdLabel, r.getRetryAttemptCaption(attempt, maxRetry), cmd.Dir)
                        cmdErr = cmd.Start()
                        r.registerCmd(cmdLabel, task, cmdMaker, cmd, stdinPipe, attempt, maxRetry, retryDelayDuration, false)
                        if cmdErr != nil </span><span class="cov0" title="0">{
                                r.handleCmdStartFailure(cmdLabel, cmdErr, cmd, attempt, maxRetry, retryDelayDuration)
                                continue</span>
                        }
                        <span class="cov6" title="34">cmdErr = cmd.Wait()
                        // no error, quit this function
                        if cmdErr == nil </span><span class="cov5" title="29">{
                                r.handleCmdWaitSuccess(cmdLabel, attempt, maxRetry)
                                executed = true
                                ch &lt;- nil
                                return
                        }</span>
                        // any error
                        <span class="cov3" title="4">r.handleCmdWaitFailure(cmdLabel, cmdErr, cmd, attempt, maxRetry, retryDelayDuration)</span>
                }
                <span class="cov2" title="2">ch &lt;- cmdErr</span>
        }()
        // checking timeout
        <span class="cov6" title="32">go func() </span><span class="cov6" title="32">{
                r.sleep(timeoutDuration)
                if executed </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov1" title="1">timeoutMessage := fmt.Sprintf("Getting timeout while running %s", cmdLabel)
                r.logger.DPrintfError("%s\n", timeoutMessage)
                ch &lt;- fmt.Errorf(timeoutMessage)</span>
        }()
        <span class="cov6" title="32">err = &lt;-ch
        return err</span>
}

func (r *Runner) waitLongRunningCmd(ch chan error) <span class="cov3" title="7">{
        seen := map[string]bool{}
        for </span><span class="cov9" title="259">{
                r.sleep(50 * time.Millisecond)
                if r.getKilledSignal() </span><span class="cov3" title="6">{
                        ch &lt;- fmt.Errorf("Terminated")
                        return
                }</span>
                <span class="cov9" title="252">r.cmdInfoMutex.Lock()
                for cmdLabel, cmdInfo := range r.cmdInfo </span><span class="cov8" title="182">{
                        if _, exist := seen[cmdLabel]; exist || !cmdInfo.IsProcess </span><span class="cov8" title="177">{
                                continue</span>
                        }
                        <span class="cov3" title="5">seen[cmdLabel] = true
                        cmd := cmdInfo.Cmd
                        go r.handleLongRunningCmd(cmdLabel, cmdInfo, cmd, ch)</span>
                }
                <span class="cov9" title="252">r.cmdInfoMutex.Unlock()</span>
        }
}

func (r *Runner) handleLongRunningCmd(cmdLabel string, cmdInfo *CmdInfo, cmd *exec.Cmd, ch chan error) <span class="cov3" title="5">{
        r.cmdInfoMutex.Lock()
        cmdTask := cmdInfo.Task
        cmdTaskName := cmdTask.GetName()
        cmdMaker := cmdInfo.CmdMaker
        maxRetry := cmdInfo.MaxRetry
        retryDelayDuration := cmdInfo.RetryDelayDuration
        r.cmdInfoMutex.Unlock()
        var stdinPipe io.WriteCloser
        var cmdErr error
        for attempt := 1; r.shouldRetry(attempt, maxRetry); attempt++ </span><span class="cov3" title="5">{
                // for attempt == 1, cmd has already been started. So we don't have to re-create and start cmd
                if attempt &gt; 1 </span><span class="cov0" title="0">{
                        cmd, stdinPipe, cmdErr = r.createCmdAndStdinPipe(cmdMaker)
                        if cmdErr != nil </span><span class="cov0" title="0">{
                                ch &lt;- cmdErr
                                return
                        }</span>
                        <span class="cov0" title="0">r.logger.DPrintfStarted("Running %s %s on %s\n", cmdLabel, r.getRetryAttemptCaption(attempt, maxRetry), cmd.Dir)
                        cmdErr = cmd.Start()
                        r.registerCmd(cmdLabel, cmdTask, cmdMaker, cmd, stdinPipe, attempt, maxRetry, retryDelayDuration, true)
                        if cmdErr != nil </span><span class="cov0" title="0">{
                                r.handleCmdStartFailure(cmdLabel, cmdErr, cmd, attempt, maxRetry, retryDelayDuration)
                                continue</span>
                        }
                }
                <span class="cov3" title="5">cmdErr = cmd.Wait()
                // no error, quit loop
                if cmdErr == nil </span><span class="cov0" title="0">{
                        r.handleCmdWaitSuccess(cmdLabel, attempt, maxRetry)
                        break</span>
                }
                // any error
                <span class="cov3" title="5">r.handleCmdWaitFailure(cmdLabel, cmdErr, cmd, attempt, maxRetry, retryDelayDuration)</span>
        }
        <span class="cov3" title="5">if cmdErr != nil </span><span class="cov3" title="5">{
                r.handleCommonLongRunningCmdFailure("exited", cmdLabel, cmdErr, cmd)
                ch &lt;- cmdErr
                return
        }</span>
        <span class="cov0" title="0">if !r.isTaskFinished(cmdTaskName) </span><span class="cov0" title="0">{
                cmdErr = fmt.Errorf("%s stopped before ready", cmdLabel)
                r.handleCommonLongRunningCmdFailure("stopped", cmdLabel, cmdErr, cmd)
                ch &lt;- cmdErr
                return
        }</span>
        <span class="cov0" title="0">r.unregisterCmd(cmdLabel)
        r.logger.DPrintfError("%s exited without any error message\n", cmdLabel)
        ch &lt;- fmt.Errorf("%s exited without any error message", cmdLabel)</span>
}

func (r *Runner) handleCommonLongRunningCmdFailure(reason string, cmdLabel string, err error, cmd *exec.Cmd) <span class="cov3" title="5">{
        errMessage := r.getCmdErrorMessage(err, cmd)
        r.logger.DPrintfError("%s %s:%s\n", cmdLabel, reason, errMessage)
        r.unregisterCmd(cmdLabel)
        r.setSurpressWaitErrorSignal()

}</span>

func (r *Runner) handleCmdWaitFailure(cmdLabel string, err error, cmd *exec.Cmd, attempt, maxRetry int, retryDelayDuration time.Duration) <span class="cov4" title="9">{
        r.handleCmdCommonFailure("Exit", cmdLabel, err, cmd, attempt, maxRetry)
        r.unregisterCmd(cmdLabel)
        if attempt != maxRetry &amp;&amp; r.shouldRetry(attempt, maxRetry) </span><span class="cov2" title="2">{
                r.sleep(retryDelayDuration)
        }</span>
}

func (r *Runner) handleCmdWaitSuccess(cmdLabel string, attempt, maxRetry int) <span class="cov5" title="29">{
        r.logger.DPrintfSuccess("Successfully running %s %s\n", cmdLabel, r.getRetryAttemptCaption(attempt, maxRetry))
}</span>

func (r *Runner) handleCmdStartFailure(cmdLabel string, err error, cmd *exec.Cmd, attempt, maxRetry int, retryDelayDuration time.Duration) <span class="cov0" title="0">{
        r.handleCmdCommonFailure("Cannot start", cmdLabel, err, cmd, attempt, maxRetry)
        r.unregisterCmd(cmdLabel)
        if attempt != maxRetry &amp;&amp; r.shouldRetry(attempt, maxRetry) </span><span class="cov0" title="0">{
                r.sleep(retryDelayDuration)
        }</span>
}

func (r *Runner) handleCmdCommonFailure(logPrefix string, cmdLabel string, err error, cmd *exec.Cmd, attempt, maxRetry int) <span class="cov4" title="9">{
        errMessage := r.getCmdErrorMessage(err, cmd)
        r.logger.DPrintfError("%s %s %s:%s\n", logPrefix, cmdLabel, r.getRetryAttemptCaption(attempt, maxRetry), errMessage)
}</span>

func (r *Runner) getCmdErrorMessage(err error, cmd *exec.Cmd) string <span class="cov4" title="14">{
        if !r.getKilledSignal() &amp;&amp; !r.getSurpressWaitErrorSignal() </span><span class="cov3" title="7">{
                return fmt.Sprintf("\n%s\n%s", r.sprintfCmdArgs(cmd), err)
        }</span>
        <span class="cov3" title="7">return fmt.Sprintf(" %s", err)</span>
}

func (r *Runner) shouldRetry(attempt, maxRetry int) bool <span class="cov6" title="51">{
        if r.getKilledSignal() </span><span class="cov3" title="7">{
                return false
        }</span>
        <span class="cov6" title="44">isInfiniteRetry := maxRetry &lt; 1 // 0 or less indicate infinity
        if isInfiniteRetry </span><span class="cov3" title="4">{
                return true
        }</span>
        <span class="cov6" title="40">return attempt &lt;= maxRetry</span>
}

func (r *Runner) getRetryAttemptCaption(attempt, maxRetry int) string <span class="cov7" title="82">{
        if maxRetry == 0 </span><span class="cov4" title="8">{
                return fmt.Sprintf("%s(Attempt %d of infinite)%s", r.decoration.Faint, attempt, r.decoration.Normal)
        }</span>
        <span class="cov7" title="74">return fmt.Sprintf("%s(Attempt %d of %d)%s", r.decoration.Faint, attempt, maxRetry, r.decoration.Normal)</span>
}

func (r *Runner) createCmdAndStdinPipe(cmdMaker func() (*exec.Cmd, error)) (cmd *exec.Cmd, stdinPipe io.WriteCloser, cmdErr error) <span class="cov6" title="40">{
        cmd, cmdErr = cmdMaker()
        if cmdErr != nil </span><span class="cov0" title="0">{
                return cmd, stdinPipe, cmdErr
        }</span>
        <span class="cov6" title="40">stdinPipe, cmdErr = cmd.StdinPipe()
        return cmd, stdinPipe, cmdErr</span>
}

func (r *Runner) registerCmd(label string, task *dsl.Task, cmdMaker func() (*exec.Cmd, error), cmd *exec.Cmd, stdinPipe io.WriteCloser, attempt int, maxRetry int, retryDelayDuration time.Duration, isProcess bool) <span class="cov6" title="40">{
        r.cmdInfoMutex.Lock()
        r.cmdInfo[label] = &amp;CmdInfo{
                Cmd:                cmd,
                IsProcess:          isProcess,
                StdInPipe:          stdinPipe,
                Task:               task,
                CmdMaker:           cmdMaker,
                Attempt:            attempt,
                MaxRetry:           maxRetry,
                RetryDelayDuration: retryDelayDuration,
        }
        r.cmdInfoMutex.Unlock()
}</span>

func (r *Runner) unregisterCmd(label string) <span class="cov6" title="46">{
        r.cmdInfoMutex.Lock()
        delete(r.cmdInfo, label)
        r.cmdInfoMutex.Unlock()
}</span>

func (r *Runner) registerTask(taskName string) (success bool) <span class="cov7" title="92">{
        r.taskStatusMutex.Lock()
        _, isStarted := r.taskStatus[taskName]
        if isStarted </span><span class="cov6" title="53">{
                success = false
        }</span> else<span class="cov6" title="39"> {
                r.taskStatus[taskName] = NewTaskStatus()
                success = true
        }</span>
        <span class="cov7" title="92">r.taskStatusMutex.Unlock()
        return success</span>
}

func (r *Runner) markTaskFinished(taskName string, err error) <span class="cov6" title="38">{
        r.taskStatusMutex.Lock()
        r.taskStatus[taskName].Finish(err)
        r.taskStatusMutex.Unlock()
}</span>

func (r *Runner) isTaskFinished(taskName string) (isFinished bool) <span class="cov7" title="69">{
        r.taskStatusMutex.RLock()
        isFinished = r.taskStatus[taskName].Finished
        r.taskStatusMutex.RUnlock()
        return isFinished
}</span>

func (r *Runner) getTaskError(taskName string) (err error) <span class="cov6" title="53">{
        r.taskStatusMutex.RLock()
        err = r.taskStatus[taskName].Error
        r.taskStatusMutex.RUnlock()
        return err
}</span>

func (r *Runner) waitTaskFinished(taskName string) (err error) <span class="cov6" title="53">{
        for </span><span class="cov7" title="69">{
                r.sleep(100 * time.Millisecond)
                if r.isTaskFinished(taskName) </span><span class="cov6" title="53">{
                        return r.getTaskError(taskName)
                }</span>
                <span class="cov5" title="16">if r.getKilledSignal() </span><span class="cov0" title="0">{
                        return fmt.Errorf("Terminated")
                }</span>
        }
}

func (r *Runner) sprintfCmdArgs(cmd *exec.Cmd) (output string) <span class="cov3" title="7">{
        d := r.decoration
        formattedArgs := []string{}
        for _, arg := range cmd.Args </span><span class="cov5" title="21">{
                rows := strings.Split(arg, "\n")
                for index, row := range rows </span><span class="cov5" title="21">{
                        prefix := "  "
                        if index == 0 </span><span class="cov5" title="21">{
                                prefix = "* "
                        }</span>
                        <span class="cov5" title="21">if len(rows) &gt; 1 </span><span class="cov0" title="0">{
                                prefix += fmt.Sprintf("%s%4d |%s ", d.Yellow, index+1, d.NoColor)
                        }</span>
                        <span class="cov5" title="21">row = strings.ReplaceAll(row, "\x1b", "\\x1b")
                        row = fmt.Sprintf("%s%s %s%s%s%s", r.spaces, d.EmptyIcon, d.Faint, prefix, row, d.Normal)
                        rows[index] = row</span>
                }
                <span class="cov5" title="21">formattedArg := strings.Join(rows, "\n")
                formattedArgs = append(formattedArgs, formattedArg)</span>
        }
        <span class="cov3" title="7">output = strings.Join(formattedArgs, "\n")
        return output</span>
}

func (r *Runner) sleep(duration time.Duration) <span class="cov10" title="455">{
        done := make(chan bool)
        ticker := time.NewTimer(duration)
        go func() </span><span class="cov10" title="455">{
                &lt;-ticker.C
                ticker.Stop()
                done &lt;- true
        }</span>()
        <span class="cov10" title="455">&lt;-done</span>
}

func (r *Runner) getProcessRow(label string, cmdInfo *CmdInfo) string <span class="cov3" title="4">{
        d := r.decoration
        pidCaption := fmt.Sprintf("(PID=%d)", cmdInfo.Cmd.Process.Pid)
        attemptCaption := r.getRetryAttemptCaption(cmdInfo.Attempt, cmdInfo.MaxRetry)
        return fmt.Sprintf("%s* %s %s%s %s%s%s", d.Faint, pidCaption, d.Normal, label, d.Faint, attemptCaption, d.Normal)
}</span>

func (r *Runner) showStatus() <span class="cov5" title="18">{
        d := r.decoration
        descriptionPrefix := r.spaces + d.EmptyIcon + d.EmptyIcon
        processPrefix := r.spaces + r.spaces + " "
        processRows := []string{}
        r.cmdInfoMutex.Lock()
        for label, cmdInfo := range r.cmdInfo </span><span class="cov3" title="4">{
                processRow := r.getProcessRow(label, cmdInfo)
                processRows = append(processRows, processRow)
        }</span>
        <span class="cov5" title="18">r.cmdInfoMutex.Unlock()
        statusCaption := r.getStatusCaption()
        r.startTimeMutex.RLock()
        elapsedTime := time.Since(r.startTime)
        elapsedTimeCaption := fmt.Sprintf("%s%sElapsed Time: %s%s\n", descriptionPrefix, d.Faint, elapsedTime, d.Normal)
        r.startTimeMutex.RUnlock()
        currentTime := time.Now()
        currentTimeString := currentTime.Format("15:04:05")
        currentTimeCaption := fmt.Sprintf("%s%sCurrent Time: %s%s\n", descriptionPrefix, d.Faint, currentTimeString, d.Normal)
        activeProcessLabel := ""
        processCaption := ""
        if len(processRows) &gt; 0 </span><span class="cov3" title="4">{
                activeProcessLabel = fmt.Sprintf("%s%sActive Process:%s\n", descriptionPrefix, d.Faint, d.Normal)
                processCaption = processPrefix + strings.Join(processRows, "\n"+processPrefix) + "\n"
        }</span>
        <span class="cov5" title="18">r.logger.DPrintfInspect("%s%s%s%s%s", statusCaption, elapsedTimeCaption, currentTimeCaption, activeProcessLabel, processCaption)</span>
}

func (r *Runner) getStatusCaption() (statusCaption string) <span class="cov5" title="18">{
        d := r.decoration
        if killed := r.getKilledSignal(); killed </span><span class="cov3" title="7">{
                return fmt.Sprintf("%sJob Ended...%s\n", d.Bold, d.Normal)
        }</span>
        <span class="cov4" title="11">if done := r.getDoneSignal(); done </span><span class="cov3" title="4">{
                return fmt.Sprintf("%s%sJob Running...%s\n", d.Bold, d.Green, d.Normal)
        }</span>
        <span class="cov3" title="7">return fmt.Sprintf("%sJob Starting...%s\n", d.Bold, d.Normal)</span>
}

func (r *Runner) killByPid(pid int, ch chan error) <span class="cov3" title="5">{
        var err error
        if _, findErr := os.FindProcess(int(pid)); findErr == nil </span><span class="cov3" title="5">{
                r.sleep(300 * time.Millisecond)
                if _, findErr := os.FindProcess(int(pid)); findErr == nil </span><span class="cov3" title="5">{
                        err = syscall.Kill(pid, syscall.SIGINT)
                }</span>
        }
        <span class="cov3" title="5">if _, findErr := os.FindProcess(int(pid)); findErr == nil </span><span class="cov3" title="5">{
                r.sleep(300 * time.Millisecond)
                if _, findErr := os.FindProcess(int(pid)); findErr == nil </span><span class="cov3" title="5">{
                        syscall.Kill(pid, syscall.SIGTERM)
                }</span>
        }
        <span class="cov3" title="5">if _, findErr := os.FindProcess(int(pid)); findErr == nil </span><span class="cov3" title="5">{
                r.sleep(300 * time.Millisecond)
                if _, findErr := os.FindProcess(int(pid)); findErr == nil </span><span class="cov3" title="5">{
                        syscall.Kill(pid, syscall.SIGKILL)
                }</span>
        }
        <span class="cov3" title="5">ch &lt;- err</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package runner

// TaskStatus represent task status
type TaskStatus struct {
        Finished bool
        Error    error
}

// NewTaskStatus create new task status
func NewTaskStatus() (ts *TaskStatus) <span class="cov10" title="39">{
        return &amp;TaskStatus{
                Finished: false,
                Error:    nil,
        }
}</span>

// Finish task status
func (ts *TaskStatus) Finish(err error) <span class="cov9" title="38">{
        ts.Finished = true
        ts.Error = err
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package strutil

import (
        "fmt"
        "math/rand"
        "strings"
        "time"
)

type NameGenerator struct {
        adjectives []string
        nouns      []string
}

func NewNameGenerator() *NameGenerator <span class="cov10" title="16">{
        return &amp;NameGenerator{
                adjectives: []string{"autumn", "hidden", "bitter", "misty", "silent",
                        "empty", "dry", "dark", "summer", "icy", "delicate", "quiet", "white", "cool",
                        "spring", "winter", "patient", "twilight", "dawn", "crimson", "wispy",
                        "weathered", "blue", "billowing", "broken", "cold", "damp", "falling",
                        "frosty", "green", "long", "late", "lingering", "bold", "little", "morning",
                        "muddy", "old", "red", "rough", "still", "small", "sparkling", "throbbing",
                        "shy", "wandering", "withered", "wild", "black", "holy", "solitary",
                        "fragrant", "aged", "snowy", "proud", "floral", "restless", "divine",
                        "polished", "purple", "lively", "nameless", "puffy", "fluffy",
                        "calm", "young", "golden", "avenging", "ancestral", "ancient", "argent",
                        "reckless", "daunting", "short", "rising", "strong", "timber", "tumbling",
                        "silver", "dusty", "celestial", "cosmic", "crescent", "double", "far", "half",
                        "inner", "milky", "northern", "southern", "eastern", "western", "outer",
                        "terrestrial", "huge", "deep", "epic", "titanic", "mighty", "powerful"},
                nouns: []string{"waterfall", "river", "breeze", "moon", "rain",
                        "wind", "sea", "morning", "snow", "lake", "sunset", "pine", "shadow", "leaf",
                        "dawn", "glitter", "forest", "hill", "cloud", "meadow", "glade",
                        "bird", "brook", "butterfly", "bush", "dew", "dust", "field",
                        "flower", "firefly", "feather", "grass", "haze", "mountain", "night", "pond",
                        "darkness", "snowflake", "silence", "sound", "sky", "shape", "surf",
                        "thunder", "violet", "wildflower", "wave", "water", "resonance",
                        "sun", "wood", "dream", "cherry", "tree", "fog", "frost", "voice", "paper",
                        "frog", "smoke", "star", "sierra", "castle", "fortress", "tiger", "day",
                        "sequoia", "cedar", "wrath", "blessing", "spirit", "nova", "storm", "burst",
                        "protector", "drake", "dragon", "knight", "fire", "king", "jungle", "queen",
                        "giant", "elemental", "throne", "game", "weed", "stone", "apogee", "bang",
                        "cluster", "corona", "cosmos", "equinox", "horizon", "light", "nebula",
                        "solstice", "spectrum", "universe", "magnitude", "parallax"},
        }
}</span>

func (generator *NameGenerator) Generate() string <span class="cov0" title="0">{
        r := rand.New(rand.New(rand.NewSource(time.Now().UnixNano())))
        adjective := generator.adjectives[r.Intn(len(generator.adjectives))]
        noun := strings.Title(generator.nouns[r.Intn(len(generator.nouns))])
        return fmt.Sprintf("%v%v", adjective, noun)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package strutil

type ReplacementMapKey []string

func (arr ReplacementMapKey) Len() int <span class="cov8" title="1">{
        return len(arr)
}</span>

func (arr ReplacementMapKey) Less(i, j int) bool <span class="cov8" title="1">{
        // longest key win
        first, second := arr[i], arr[j]
        return len(second) &lt; len(first)
}</span>

func (arr ReplacementMapKey) Swap(i, j int) <span class="cov8" title="1">{
        arr[i], arr[j] = arr[j], arr[i]
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package strutil

import (
        "fmt"
        "regexp"
        "sort"
        "strings"
        "unicode"
)

func StrQuote(s string, quote byte) (result string) <span class="cov0" title="0">{
        if len(s) &gt; 0 &amp;&amp; s[0] == quote &amp;&amp; s[len(s)-1] == quote </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">quoteEscapedStr := strings.ReplaceAll(s, string(quote), "\\"+string(quote))
        return fmt.Sprintf("%s%s%s", string(quote), quoteEscapedStr, string(quote))</span>
}

func StrDoubleQuote(s string) (result string) <span class="cov0" title="0">{
        return StrQuote(s, '"')
}</span>

func StrSingleQuote(s string) (result string) <span class="cov0" title="0">{
        return StrQuote(s, '\'')
}</span>

func StrEscapeShellValue(value string) (result string) <span class="cov0" title="0">{
        escapedValue := strings.ReplaceAll(value, "'", "'\"'\"'")
        return fmt.Sprintf("'%s'", escapedValue)
}</span>

func StrShellVariable(key, value string) (result string) <span class="cov0" title="0">{
        return fmt.Sprintf("%s=%s", key, StrEscapeShellValue(value))
}</span>

func strIndent(multiLineStr string, indentation string, skipFirstLine bool) (indentedStr string) <span class="cov3" title="4">{
        lines := strings.Split(multiLineStr, "\n")
        for index, line := range lines </span><span class="cov4" title="5">{
                if index == 0 &amp;&amp; skipFirstLine </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov3" title="4">if strings.Trim(line, " ") != "" </span><span class="cov3" title="4">{
                        lines[index] = indentation + line
                }</span>
        }
        <span class="cov3" title="4">return strings.Join(lines, "\n")</span>
}

// indent second-last lines
func StrIndent(multiLineStr string, indentation string) (indentedStr string) <span class="cov1" title="1">{
        return strIndent(multiLineStr, indentation, true)
}</span>

// indent all lines
func StrFullIndent(multiLineStr string, indentation string) (indentedStr string) <span class="cov3" title="3">{
        return strIndent(multiLineStr, indentation, false)
}</span>

func StrRepeat(s string, repetition int) (result string) <span class="cov3" title="3">{
        result = ""
        for i := 0; i &lt; repetition; i++ </span><span class="cov5" title="9">{
                result += s
        }</span>
        <span class="cov3" title="3">return result</span>
}

func StrGetIndentation(s string, level int) (result string, err error) <span class="cov3" title="3">{
        rex := regexp.MustCompile("^([ \t]+).*$")
        match := rex.FindStringSubmatch(s)
        if len(match) &lt; 2 </span><span class="cov3" title="3">{
                return "", nil
        }</span>
        <span class="cov0" title="0">totalIndentation := match[1]
        indentationLength := len(totalIndentation) / level
        result = s[:indentationLength]
        if StrRepeat(result, level) != totalIndentation </span><span class="cov0" title="0">{
                return result, fmt.Errorf("cannot determine single %d indentation for '%s'", level, s)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func StrReplace(s string, replacementMap map[string]string) (result string) <span class="cov1" title="1">{
        result = s
        keys := []string{}
        for key := range replacementMap </span><span class="cov2" title="2">{
                keys = append(keys, key)
        }</span>
        <span class="cov1" title="1">sort.Sort(ReplacementMapKey(keys))
        for _, key := range keys </span><span class="cov2" title="2">{
                val := replacementMap[key]
                if re, err := regexp.Compile(key); err == nil </span><span class="cov2" title="2">{
                        result = re.ReplaceAllStringFunc(result, func(text string) string </span><span class="cov3" title="3">{
                                indentation, _ := StrGetIndentation(text, 1)
                                indentedVal := StrFullIndent(val, indentation)
                                return re.ReplaceAllString(text, indentedVal)
                        }</span>)
                } else<span class="cov0" title="0"> {
                        result = strings.ReplaceAll(result, key, val)
                }</span>
        }
        <span class="cov1" title="1">return result</span>
}

func StrGetLineSubmatch(lines, patterns []string, desiredPatternIndex int) (matchIndex int, submatch []string, err error) <span class="cov3" title="4">{
        patternIndex := 0
        if desiredPatternIndex &lt; 0 </span><span class="cov0" title="0">{
                desiredPatternIndex = len(patterns) + desiredPatternIndex
        }</span>
        <span class="cov3" title="4">rex, err := regexp.Compile(patterns[patternIndex])
        if err != nil </span><span class="cov1" title="1">{
                return -1, submatch, err
        }</span>
        <span class="cov3" title="3">for lineIndex, line := range lines </span><span class="cov6" title="14">{
                match := rex.FindStringSubmatch(line)
                if len(match) == 0 </span><span class="cov5" title="7">{
                        continue</span>
                }
                <span class="cov5" title="7">if patternIndex == desiredPatternIndex </span><span class="cov1" title="1">{
                        matchIndex = lineIndex
                        submatch = match
                }</span>
                <span class="cov5" title="7">if patternIndex == len(patterns)-1 </span><span class="cov1" title="1">{
                        return matchIndex, submatch, nil
                }</span>
                <span class="cov4" title="6">patternIndex++
                rex, err = regexp.Compile(patterns[patternIndex])
                if err != nil </span><span class="cov1" title="1">{
                        return -1, submatch, err
                }</span>
        }
        <span class="cov1" title="1">return -1, submatch, nil</span>
}

func strPrepareLinesForReplacement(lines []string) (preparedLines []string) <span class="cov4" title="5">{
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return []string{""}
        }</span>
        <span class="cov4" title="5">return lines</span>
}

func StrReplaceLineAtIndex(lines []string, index int, replacements []string) (result []string, err error) <span class="cov4" title="5">{
        lines = strPrepareLinesForReplacement(lines)
        if index &lt; 0 || index &gt;= len(lines) </span><span class="cov2" title="2">{
                return []string{}, fmt.Errorf("index out of bound: %d", index)
        }</span>
        <span class="cov3" title="3">tmpLines := []string{}
        tmpLines = append(tmpLines, lines[:index]...)
        tmpLines = append(tmpLines, replacements...)
        if index &lt; len(lines) </span><span class="cov3" title="3">{
                tmpLines = append(tmpLines, lines[index+1:]...)
        }</span>
        <span class="cov3" title="3">content := strings.Join(tmpLines, "\n")
        result = strings.Split(content, "\n")
        return result, nil</span>
}

func StrSubmatch(s string, pattern string) (result []string, err error) <span class="cov0" title="0">{
        rex, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov0" title="0">result = rex.FindStringSubmatch(s)
        return result, err</span>
}

func StrTitle(s string) string <span class="cov5" title="7">{
        // This function is
        // Use a closure here to remember state.
        // Hackish but effective. Depends on Map scanning in order and calling
        // the closure once per rune.
        prev := ' '
        return strings.Map(
                func(r rune) rune </span><span class="cov10" title="70">{
                        if isSeparator(prev) </span><span class="cov5" title="10">{
                                prev = r
                                return unicode.ToTitle(r)
                        }</span>
                        <span class="cov9" title="60">prev = r
                        return r</span>
                },
                s)
}

func isSeparator(r rune) bool <span class="cov10" title="70">{
        // ASCII alphanumerics and underscore are not separators
        if r &lt;= 0x7F </span><span class="cov10" title="70">{
                switch </span>{
                case '0' &lt;= r &amp;&amp; r &lt;= '9':<span class="cov0" title="0">
                        return false</span>
                case 'a' &lt;= r &amp;&amp; r &lt;= 'z':<span class="cov9" title="56">
                        return false</span>
                case 'A' &lt;= r &amp;&amp; r &lt;= 'Z':<span class="cov3" title="4">
                        return false</span>
                case r == '_':<span class="cov0" title="0">
                        return false</span>
                }
                <span class="cov5" title="10">return true</span>
        }
        // Letters and digits are not separators
        <span class="cov0" title="0">if unicode.IsLetter(r) || unicode.IsDigit(r) </span><span class="cov0" title="0">{
                return false
        }</span>
        // Otherwise, all we can do for now is treat spaces as separators.
        <span class="cov0" title="0">return unicode.IsSpace(r)</span>
}

func StrToCamel(s string) (result string) <span class="cov3" title="4">{
        rex := regexp.MustCompile("[^a-zA-Z0-9]+")
        strippedStr := rex.ReplaceAllString(s, " ")
        titledStr := StrTitle(strippedStr)
        result = strings.ReplaceAll(titledStr, " ", "")
        if len(result) &gt; 0 </span><span class="cov2" title="2">{
                firstLetter := strings.ToLower(string(result[0]))
                rest := result[1:]
                return firstLetter + rest
        }</span>
        <span class="cov2" title="2">return result</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package strutil

import (
        "encoding/base64"
        "fmt"
        "regexp"
        "strings"
        "time"

        pluralize "github.com/gertd/go-pluralize"
        "github.com/google/uuid"
)

type StrUtil struct {
        nameGenerator *NameGenerator
        pluralize     *pluralize.Client
}

func NewStrUtil() *StrUtil <span class="cov10" title="16">{
        return &amp;StrUtil{
                nameGenerator: NewNameGenerator(),
                pluralize:     pluralize.NewClient(),
        }
}</span>

func (strUtil *StrUtil) IsSingular(s string) (result bool) <span class="cov0" title="0">{
        return strUtil.pluralize.IsSingular(s)
}</span>

func (strUtil *StrUtil) IsPlural(s string) (result bool) <span class="cov0" title="0">{
        return strUtil.pluralize.IsPlural(s)
}</span>

func (strUtil *StrUtil) IsUpper(s string) (result bool) <span class="cov3" title="2">{
        return strings.ToUpper(s) == s
}</span>

func (strUtil *StrUtil) IsLower(s string) (result bool) <span class="cov3" title="2">{
        return strings.ToLower(s) == s
}</span>

func (strUtil *StrUtil) ToPlural(s string) (result string) <span class="cov0" title="0">{
        return strUtil.pluralize.Plural(s)
}</span>

func (strUtil *StrUtil) ToSingular(s string) (result string) <span class="cov0" title="0">{
        return strUtil.pluralize.Singular(s)
}</span>

func (strUtil *StrUtil) ToUpper(s string) (result string) <span class="cov0" title="0">{
        return strings.ToUpper(s)
}</span>

func (strUtil *StrUtil) ToLower(s string) (result string) <span class="cov0" title="0">{
        return strings.ToLower(s)
}</span>

func (strUtil *StrUtil) ToCamel(s string) (result string) <span class="cov5" title="4">{
        return StrToCamel(s)
}</span>

func (strUtil *StrUtil) ToPascal(s string) (result string) <span class="cov3" title="2">{
        return StrTitle(strUtil.ToCamel(s))
}</span>

func (strUtil *StrUtil) ToUpperSnake(s string) (result string) <span class="cov0" title="0">{
        return strUtil.ToUpper(strUtil.ToSnake(s))
}</span>

func (strUtil *StrUtil) ToTitle(s string) (result string) <span class="cov1" title="1">{
        return StrTitle(strUtil.splitByCapital(s, " "))
}</span>

func (strUtil *StrUtil) ToSnake(s string) (result string) <span class="cov1" title="1">{
        return strUtil.splitByCapital(s, "_")
}</span>

func (strUtil *StrUtil) ToKebab(s string) (result string) <span class="cov1" title="1">{
        return strUtil.splitByCapital(s, "-")
}</span>

func (strUtil *StrUtil) splitByCapital(str, separator string) (result string) <span class="cov4" title="3">{
        firstCapPattern := regexp.MustCompile("(.)([A-Z][a-z]+)")
        allCapPattern := regexp.MustCompile("([a-z0-9])([A-Z])")
        spacePattern := regexp.MustCompile(" ")
        consecutiveSeparatorPattern := regexp.MustCompile(fmt.Sprintf("[%s]+", separator))
        forbiddenPattern := regexp.MustCompile(fmt.Sprintf("[^a-zA-Z0-9\\%s]+", separator))
        newStr := firstCapPattern.ReplaceAllString(str, fmt.Sprintf("${1}%s${2}", separator))
        newStr = allCapPattern.ReplaceAllString(newStr, fmt.Sprintf("${1}%s${2}", separator))
        newStr = spacePattern.ReplaceAllString(newStr, separator)
        newStr = consecutiveSeparatorPattern.ReplaceAllString(newStr, separator)
        newStr = forbiddenPattern.ReplaceAllString(newStr, "")
        newStr = strings.Trim(newStr, separator)
        return strings.ToLower(newStr)
}</span>

func (strUtil *StrUtil) Quote(s string, quote byte) (result string) <span class="cov0" title="0">{
        return StrQuote(s, quote)
}</span>

func (strUtil *StrUtil) DoubleQuote(s string) (result string) <span class="cov0" title="0">{
        return StrDoubleQuote(s)
}</span>

func (strUtil *StrUtil) SingleQuote(s string) (result string) <span class="cov0" title="0">{
        return StrSingleQuote(s)
}</span>

func (strUtil *StrUtil) EscapeShellValue(s string) (result string) <span class="cov0" title="0">{
        return StrEscapeShellValue(s)
}</span>

// indent second-last lines
func (strUtil *StrUtil) Indent(multiLineStr string, indentation string) (indentedStr string) <span class="cov1" title="1">{
        return StrIndent(multiLineStr, indentation)
}</span>

func (strUtil *StrUtil) FullIndent(multiLineStr string, indentation string) (indentedStr string) <span class="cov0" title="0">{
        return StrFullIndent(multiLineStr, indentation)
}</span>

func (strUtil *StrUtil) Repeat(s string, repetition int) (result string) <span class="cov4" title="3">{
        return StrRepeat(s, repetition)
}</span>

func (strUtil *StrUtil) GetIndentation(s string, level int) (result string, err error) <span class="cov4" title="3">{
        rex := regexp.MustCompile("^([ \t]+).*$")
        match := rex.FindStringSubmatch(s)
        if len(match) &lt; 2 </span><span class="cov1" title="1">{
                return "", nil
        }</span>
        <span class="cov3" title="2">totalIndentation := match[1]
        indentationLength := len(totalIndentation) / level
        result = s[:indentationLength]
        if strUtil.Repeat(result, level) != totalIndentation </span><span class="cov1" title="1">{
                return result, fmt.Errorf("cannot determine single %d indentation for '%s'", level, s)
        }</span>
        <span class="cov1" title="1">return result, nil</span>
}

func (strUtil *StrUtil) Submatch(s string, pattern string) (result []string, err error) <span class="cov0" title="0">{
        return StrSubmatch(s, pattern)
}</span>

func (strUtil *StrUtil) Split(s string, separator string) (result []string) <span class="cov0" title="0">{
        return strings.Split(s, separator)
}</span>

func (strUtil *StrUtil) PadRight(s string, length int, pad string) (result string) <span class="cov0" title="0">{
        for len(s) &lt; length </span><span class="cov0" title="0">{
                s = s + pad
        }</span>
        <span class="cov0" title="0">return s</span>
}

func (strUtil *StrUtil) PadLeft(s string, length int, pad string) (result string) <span class="cov0" title="0">{
        for len(s) &lt; length </span><span class="cov0" title="0">{
                s = pad + s
        }</span>
        <span class="cov0" title="0">return s</span>
}

func (struUtil *StrUtil) NewUUID() (uuidStr string) <span class="cov0" title="0">{
        return uuid.NewString()
}</span>

func (struUtil *StrUtil) AddPrefix(s, prefix string) (prefixedStr string) <span class="cov0" title="0">{
        if strings.HasPrefix(s, prefix) </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return prefix + s</span>
}

func (strUtil *StrUtil) Trim(str, cutset string) (trimmedStr string) <span class="cov0" title="0">{
        return strings.Trim(str, cutset)
}</span>

func (strUtil *StrUtil) NewName() (randomName string) <span class="cov0" title="0">{
        return strUtil.nameGenerator.Generate()
}</span>

func (strUtil *StrUtil) CurrentTime() (currentTimeStr string) <span class="cov0" title="0">{
        now := time.Now()
        return now.Format("20060102150405")
}</span>

func (strUtil *StrUtil) EncodeBase64(str string) (result string) <span class="cov0" title="0">{
        return base64.StdEncoding.EncodeToString([]byte(str))
}</span>

func (strUtil *StrUtil) DecodeBase64(str string) (result string, err error) <span class="cov0" title="0">{
        sd, err := base64.StdEncoding.DecodeString(str)
        return string(sd), err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package toc

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/state-alchemists/zaruba/dsl"
)

var startTocTag = "&lt;!--startToc--&gt;"
var endTocTag = "&lt;!--endToc--&gt;"
var startTocHeaderTag = "&lt;!--startTocHeader--&gt;"
var endTocHeaderTag = "&lt;!--endTocHeader--&gt;"
var startTocSubtopicTag = "&lt;!--startTocSubtopic--&gt;"
var endTocSubtopicTag = "&lt;!--endTocSubtopic--&gt;"

func splitContentByTag(util *dsl.DSLUtil, startTag, endTag, content string) (beforeTag, inTag, afterTag string, isTagFound bool) <span class="cov10" title="4">{
        r := regexp.MustCompile(fmt.Sprintf("(?s)(.*)%s(.*)%s(.*)", startTag, endTag))
        matches := r.FindStringSubmatch(content)
        isTagFound = false
        if len(matches) &gt; 3 </span><span class="cov10" title="4">{
                beforeTag = matches[1]
                inTag = matches[2]
                afterTag = matches[3]
                isTagFound = true
        }</span>
        <span class="cov10" title="4">return beforeTag, inTag, afterTag, isTagFound</span>
}

func replaceTag(util *dsl.DSLUtil, startTag, endTag, content, replacement string) (newContent string) <span class="cov8" title="3">{
        beforeTag, _, afterTag, isTagFound := splitContentByTag(util, startTag, endTag, content)
        if !isTagFound </span><span class="cov0" title="0">{
                return content
        }</span>
        <span class="cov8" title="3">if len(replacement) &gt; 0 </span><span class="cov8" title="3">{
                if replacement[0] != '\n' </span><span class="cov8" title="3">{
                        replacement = "\n" + replacement
                }</span>
                <span class="cov8" title="3">if replacement[len(replacement)-1] != '\n' </span><span class="cov8" title="3">{
                        replacement = replacement + "\n"
                }</span>
        }
        <span class="cov8" title="3">if replacement == "" </span><span class="cov0" title="0">{
                replacement = "\n"
        }</span>
        <span class="cov8" title="3">return strings.Join([]string{
                beforeTag,
                startTag,
                replacement,
                endTag,
                afterTag,
        }, "")</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package toc

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/state-alchemists/zaruba/dsl"
)

type Toc struct {
        FileLocation string
        FileContent  string
        Items        TocItems
        Util         *dsl.DSLUtil
}

func (toc *Toc) RenderNewContent() (err error) <span class="cov8" title="1">{
        dirPath := filepath.Dir(toc.FileLocation)
        newTocSection := ""
        if len(toc.Items) &gt; 0 </span><span class="cov8" title="1">{
                newTocSection, err = toc.Items.AsLinks(0, dirPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">newContent := replaceTag(toc.Util, startTocTag, endTocTag, toc.FileContent, newTocSection)
        if err := toc.Util.File.WriteText(toc.FileLocation, newContent, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // render toc items
        <span class="cov8" title="1">return toc.Items.RenderNewContent()</span>
}

func NewToc(fileLocation string) (toc *Toc, err error) <span class="cov8" title="1">{
        absFileLocation := fileLocation
        if !filepath.IsAbs(absFileLocation) </span><span class="cov8" title="1">{
                absFileLocation, err = filepath.Abs(absFileLocation)
                if err != nil </span><span class="cov0" title="0">{
                        return toc, err
                }</span>
        }
        <span class="cov8" title="1">util := dsl.NewDSLUtil()
        fileContent, err := util.File.ReadText(absFileLocation)
        if err != nil </span><span class="cov0" title="0">{
                return toc, err
        }</span>
        <span class="cov8" title="1">toc = &amp;Toc{
                FileLocation: absFileLocation,
                FileContent:  fileContent,
                Util:         util,
        }
        _, tocContent, _, isTagFound := splitContentByTag(util, startTocTag, endTocTag, fileContent)
        if !isTagFound </span><span class="cov0" title="0">{
                return toc, fmt.Errorf("no tag found at '%s', expecting '%s' and '%s'", absFileLocation, startTocTag, endTocTag)
        }</span>
        <span class="cov8" title="1">tocLines := strings.Split(tocContent, "\n")
        toc.Items, err = NewTocItems(toc, nil, 0, tocLines)
        if err != nil </span><span class="cov0" title="0">{
                return toc, err
        }</span>
        <span class="cov8" title="1">return toc, err</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package toc

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

type TocItem struct {
        Level           int
        Title           string
        KebabCaseTitle  string
        OldFileLocation string
        NewFileLocation string
        Children        TocItems
        Parent          *TocItem
        Toc             *Toc
}

func (tocItem *TocItem) RenderNewContent() (err error) <span class="cov7" title="12">{
        tocHeader, err := tocItem.GetTocHeader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="12">dirPath := filepath.Dir(tocItem.NewFileLocation)
        tocSubtopic, err := tocItem.Children.AsLinks(tocItem.Level+1, dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="12">if tocSubtopic != "" </span><span class="cov5" title="5">{
                tocSubtopic = strings.Join([]string{"# Subtopics", tocSubtopic}, "\n")
        }</span>
        <span class="cov7" title="12">util := tocItem.Toc.Util
        oldFileExist, oldFileExistErr := util.File.IsExist(tocItem.OldFileLocation)
        // old file location is not defined or not exist
        if tocItem.OldFileLocation == "" || !oldFileExist || oldFileExistErr != nil </span><span class="cov7" title="11">{
                if err := tocItem.RenderNewContentToNewFile(tocHeader, tocSubtopic); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov7" title="11">return tocItem.Children.RenderNewContent()</span>
        }
        // old file location is defined
        <span class="cov1" title="1">if err := tocItem.RenderNewContentFromOldFile(tocHeader, tocSubtopic); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // also render children
        <span class="cov1" title="1">return tocItem.Children.RenderNewContent()</span>
}

func (tocItem *TocItem) RenderNewContentFromOldFile(tocHeader, tocSubtopic string) (err error) <span class="cov1" title="1">{
        util := tocItem.Toc.Util
        oldFileContent, err := util.File.ReadText(tocItem.OldFileLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">newFileContent := replaceTag(util, startTocHeaderTag, endTocHeaderTag, oldFileContent, tocHeader)
        newFileContent = replaceTag(util, startTocSubtopicTag, endTocSubtopicTag, newFileContent, tocSubtopic)
        if err := util.File.WriteText(tocItem.NewFileLocation, newFileContent, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if tocItem.OldFileLocation != tocItem.NewFileLocation </span><span class="cov1" title="1">{
                oldFileExist, oldFileExistErr := util.File.IsExist(tocItem.OldFileLocation)
                if oldFileExist &amp;&amp; oldFileExistErr == nil </span><span class="cov1" title="1">{
                        return os.Remove(tocItem.OldFileLocation)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (tocItem *TocItem) RenderNewContentToNewFile(tocHeader, tocSubtopic string) (err error) <span class="cov7" title="11">{
        newFileContent := strings.Join([]string{
                startTocHeaderTag,
                tocHeader,
                endTocHeaderTag,
                "",
                fmt.Sprintf("&gt; TODO: Write about `%s`.", tocItem.Title),
                "",
                tocItem.GetNewTaggedSubtopicContent(tocSubtopic),
        }, "\n")
        return tocItem.Toc.Util.File.WriteText(tocItem.NewFileLocation, newFileContent, 0755)
}</span>

func (tocItem *TocItem) GetNewTaggedSubtopicContent(tocSubtopic string) string <span class="cov7" title="11">{
        if tocSubtopic == "" </span><span class="cov6" title="7">{
                return strings.Join([]string{startTocSubtopicTag, endTocSubtopicTag}, "\n")
        }</span>
        <span class="cov4" title="4">return strings.Join([]string{startTocSubtopicTag, tocSubtopic, endTocSubtopicTag}, "\n")</span>
}

func (tocItem *TocItem) GetTocHeader() (tocHeader string, err error) <span class="cov7" title="12">{
        parentLink, err := tocItem.GetParentLinksAsString()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="12">tocHeader = strings.Join([]string{
                parentLink,
                fmt.Sprintf("# %s", tocItem.Title),
        }, "\n")
        return tocHeader, nil</span>
}

func (tocItem *TocItem) AsLinks(level int, dirPath string) (links string, err error) <span class="cov10" title="30">{
        singleLink, err := tocItem.AsLink(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="30">lines := []string{fmt.Sprintf(`%s- %s`, strings.Repeat("  ", tocItem.Level-level), singleLink)}
        if len(tocItem.Children) != 0 </span><span class="cov6" title="9">{
                childrenLines, err := tocItem.Children.AsLinks(level, dirPath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov6" title="9">lines = append(lines, childrenLines)</span>
        }
        <span class="cov10" title="30">return strings.Join(lines, "\n"), nil</span>
}

func (tocItem *TocItem) AsLink(dirPath string) (link string, err error) <span class="cov10" title="30">{
        relativeUrl, err := filepath.Rel(dirPath, tocItem.NewFileLocation)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="30">return fmt.Sprintf(`[%s](%s)`, tocItem.Title, relativeUrl), nil</span>
}

func (tocItem *TocItem) GetParentLinksAsString() (str string, err error) <span class="cov7" title="12">{
        dirPath := filepath.Dir(tocItem.NewFileLocation)
        parent := tocItem.Parent
        links := []string{}
        // add link to parent files
        for parent != nil </span><span class="cov8" title="18">{
                absUrl := parent.NewFileLocation
                relativeUrl, err := filepath.Rel(dirPath, absUrl)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="18">link := fmt.Sprintf("[%s](%s)", parent.Title, relativeUrl)
                links = append([]string{link}, links...)
                parent = parent.Parent</span>
        }
        // add link to TOC file
        <span class="cov7" title="12">absUrl := tocItem.Toc.FileLocation
        relativeUrl, err := filepath.Rel(dirPath, absUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="12">link := fmt.Sprintf("[](%s)", relativeUrl)
        links = append([]string{link}, links...)
        return strings.Join(links, " &gt; "), nil</span>
}

func (tocItem *TocItem) SetNewFileLocation() <span class="cov7" title="12">{
        tocFileLocation := tocItem.Toc.FileLocation
        tocDirPath := filepath.Dir(tocFileLocation)
        pathList := []string{tocItem.getNewFileName()}
        parent := tocItem.Parent
        for parent != nil </span><span class="cov8" title="18">{
                pathList = append([]string{parent.KebabCaseTitle}, pathList...)
                parent = parent.Parent
        }</span>
        <span class="cov7" title="12">pathList = append([]string{tocDirPath}, pathList...)
        tocItem.NewFileLocation = filepath.Join(pathList...)</span>
}

func (tocItem *TocItem) getNewFileName() (fileName string) <span class="cov7" title="12">{
        if len(tocItem.Children) == 0 </span><span class="cov6" title="7">{
                return fmt.Sprintf("%s.md", tocItem.KebabCaseTitle)
        }</span>
        <span class="cov5" title="5">return filepath.Join(tocItem.KebabCaseTitle, "README.md")</span>
}

func NewTocItem(toc *Toc, parent *TocItem, level int, title, oldFileLocation string) (tocItem *TocItem) <span class="cov7" title="12">{
        if oldFileLocation != "" &amp;&amp; !filepath.IsAbs(oldFileLocation) </span><span class="cov1" title="1">{
                tocFileLocation := toc.FileLocation
                tocDirPath := filepath.Dir(tocFileLocation)
                oldFileLocation = filepath.Join(tocDirPath, oldFileLocation)
        }</span>
        <span class="cov7" title="12">tocItem = &amp;TocItem{
                Level:           level,
                Title:           title,
                KebabCaseTitle:  toc.Util.Str.ToKebab(title),
                OldFileLocation: oldFileLocation,
                Parent:          parent,
                Toc:             toc,
        }
        return tocItem</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package toc

import (
        "regexp"
        "strings"
)

type TocItems []*TocItem

func (tocItems TocItems) AsLinks(level int, dirPath string) (str string, err error) <span class="cov9" title="22">{
        lines := []string{}
        for _, tocItem := range tocItems </span><span class="cov9" title="30">{
                line, err := tocItem.AsLinks(level, dirPath)
                if err != nil </span><span class="cov0" title="0">{
                        return str, err
                }</span>
                <span class="cov9" title="30">lines = append(lines, line)</span>
        }
        <span class="cov9" title="22">return strings.Join(lines, "\n"), nil</span>
}

func (tocItems TocItems) RenderNewContent() (err error) <span class="cov7" title="13">{
        for _, tocItem := range tocItems </span><span class="cov7" title="12">{
                if err := tocItem.RenderNewContent(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov7" title="13">return nil</span>
}

func NewTocItems(toc *Toc, parent *TocItem, level int, lines []string) (tocItems TocItems, err error) <span class="cov5" title="6">{
        tocItems = []*TocItem{}
        completePattern, _ := regexp.Compile(`^([ \t]*)[\*-] \[(.*)\]\((.*)\).*$`)
        minimalPattern, _ := regexp.Compile(`^([ \t]*)[\*-] (.*)$`)
        baseIndentation := ""
        var lastItem *TocItem
        childLines := []string{}
        firstMatch := true
        for _, line := range lines </span><span class="cov10" title="32">{
                match := completePattern.FindStringSubmatch(line)
                if len(match) == 0 </span><span class="cov9" title="30">{
                        // complete pattern failed, try minimal pattern
                        match = minimalPattern.FindStringSubmatch(line)
                }</span>
                // complete/minimal pattern match
                <span class="cov10" title="32">if len(match) &gt; 0 </span><span class="cov9" title="30">{
                        indentation := match[1]
                        title := match[2]
                        fileLocation := ""
                        if len(match) &gt; 3 </span><span class="cov2" title="2">{
                                fileLocation = match[3]
                        }</span>
                        // get baseIndentation
                        <span class="cov9" title="30">if firstMatch </span><span class="cov5" title="6">{
                                baseIndentation = indentation
                                lastItem = NewTocItem(toc, parent, level, title, fileLocation)
                                tocItems = append(tocItems, lastItem)
                                firstMatch = false
                                continue</span>
                        }
                        // childLines
                        <span class="cov9" title="24">if len(indentation) &gt; len(baseIndentation) </span><span class="cov8" title="18">{
                                childLines = append(childLines, line)
                                continue</span>
                        }
                        // new item
                        <span class="cov5" title="6">if len(indentation) &gt;= len(baseIndentation) </span><span class="cov5" title="6">{
                                // wrap up previous lastItem
                                if len(childLines) &gt; 0 </span><span class="cov3" title="3">{
                                        // make sure we only do this when childLines exist
                                        lastItem.Children, err = NewTocItems(toc, lastItem, level+1, childLines)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return tocItems, err
                                        }</span>
                                        <span class="cov3" title="3">childLines = []string{}</span>
                                }
                                <span class="cov5" title="6">lastItem.SetNewFileLocation()
                                // set current line as last item
                                lastItem = NewTocItem(toc, parent, level, title, fileLocation)
                                tocItems = append(tocItems, lastItem)</span>
                        }
                }
        }
        // there are unfinished businesses
        <span class="cov5" title="6">if lastItem != nil </span><span class="cov5" title="6">{
                if len(childLines) &gt; 0 </span><span class="cov2" title="2">{
                        // make sure we only do this when childLines exist
                        lastItem.Children, err = NewTocItems(toc, lastItem, level+1, childLines)
                        if err != nil </span><span class="cov0" title="0">{
                                return tocItems, err
                        }</span>
                }
                <span class="cov5" title="6">lastItem.SetNewFileLocation()</span>
        }
        <span class="cov5" title="6">return tocItems, err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
